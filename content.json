{"pages":[],"posts":[{"title":"Java IO流","text":"字节流、字符流、缓存流、转换流、属性集、序列流、打印流 IO 操作Java中I/O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出数据。 IO的分类根据数据的流向分： 输入流 ：把数据从其他设备上读取到内存中的流。 输出流 ：把数据从内存 中写出到其他设备上的流。 根据数据的类型分 字节流 ：以字节为单位，读写数据的流。 字符流 ：以字符为单位，读写数据的流。 IO流相关类123456789101112131415IO流 |--字节流 |--InputStream 输入流 |--FileInputStream |--BufferedInputStream |--OutputStream 输出流 |--FileOutputStream |--BufferedOutputStream |--字符流 |--Reader |--FileReader 输入流 |--BufferedReader |--Writer |--FileWriter 输出流 |--BufferedWriter 字节流一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。 字节输出流OutputStreamjava.io.OutputStream抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。 public void close() ：关闭此输出流并释放资源。 完成流操作后一定要close public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len) public abstract void write(int b) ：将指定的字节输出流。 FileOutputStream类：文件输出流 public FileOutputStream(File file)：创建文件输出流， File文件对象 public FileOutputStream(String name)： 创建文件输出流， name文件名 没有这个文件，则创建，有则清空数据 public FileOutputStream(File file, boolean append)： public FileOutputStream(String name, boolean append)： append为true 表示追加数据， 为false同上面两个构造方法 例子 1234567OutputStream out = new FileOutputStream(\"./src/Demo11/IO/file.txt\");out.write('t');out.write('a');out.write('n');out.write('\\n');out.write(\"hello!\".getBytes());out.close(); 字节输入流InputStreamjava.io.InputStream抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。 public void close() ：关闭此输入流并释放资源。 完成流操作后一定要close public abstract int read()： 从输入流读取数据的下一个字节，没读到返回-1。 public int read(byte[] b)： 从输入流中读取一些字节数，将它们存储到字节数组 b中 返回读取的字节数， 没有读到内容才会返回-1 FileInputStream类: 文件输入流 FileInputStream(File file)： FileInputStream(String name)： 没有这个文件,会抛出FileNotFoundException 。 例子 123456789InputStream in = new FileInputStream(\"./src/Demo11/IO/file.txt\");System.out.print((char)in.read());System.out.print((char)in.read());byte[] bytes = new byte[5];int len = 0;while ((len = in.read(bytes)) != -1) { System.out.print(new String(bytes, 0, len));}in.close(); 字符流字符流专门用于处理文本文件。使用字节流读取文本文件时，遇到中文字符可能不会显示完整的字符。 字符输入流Readerjava.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。 public void close() ：关闭此流并释放资源。 public int read()： 从输入流读取一个字符, 没读到返回-1。 public int read(char[] cbuf)： 返回读取的字节数， 没有读到内容才会返回-1 FileReader 类：构造时使用系统默认的字符编码和默认字节缓冲区。 FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。 FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。 字符输出流Writerjava.io.Writer抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。 void write(int c) 写入单个字符。 void write(char[] cbuf)写入字符数组。 abstract void write(char[] cbuf, int off, int len): off开始索引, len写入字符数 void write(String str)写入字符串。 void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。 void flush()刷新该流的缓冲。 void close() 关闭此流，但要先刷新它。 FileWriter类： 构造时使用系统默认的字符编码和默认字节缓冲区。 FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。 FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。 关闭/刷新缓冲区 flush ：刷新缓冲区，流对象可以继续使用。 缓冲区满了，无需调用flush方法便会自动刷新。 但没有刷新缓冲区，无法写入字符到文件中。 close:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了 属性集Propertiesjava.util.Properties 继承于Hashtable ，来表示一个持久的属性集, 可保存在流中或从流中加载。它使用键值结构存储数据，且键和值都是字符串类型。 public Properties() :创建一个空的属性列表。 public Object setProperty(String key, String value) ： 保存一对属性。 public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。 public Set&lt;String&gt; stringPropertyNames() ：所有键的名称的集合。 与流相关的方法 void store(OutputStream out, String comments)将此 Properties 表中的属性列表（键和元素对）写入输出流。 void store(Writer writer, String comments)将此 Properties 表中的属性列表（键和元素对）写入输出字符。 public void load(InputStream inStream)： 从字节输入流中读取键值对。 void load(Reader reader)从输入字符流中读取属性列表（键和元素对）。 例子 1234567891011121314151617FileWriter fw = new FileWriter(\"prop.file\");FileReader fr = new FileReader(\"prop.file\");Properties prop = new Properties();prop.setProperty(\"1\", \"tan1\");prop.setProperty(\"2\", \"tan2\");// 写入到流中prop.store(fw, \"test properties\");// 从流中读取Properties p2 = new Properties();p2.load(fr);for (String key : p2.stringPropertyNames()) { System.out.println(key + \" = \" + p2.getProperty(key));} 缓冲流缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流。 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。 public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。 字符缓冲流的基本方法与普通字符流调用方式一致， 需要注意的是缓存流的close方法会关闭传入普通字符流 转换流InputStreamReader类转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。 它读取字节，并使用指定的字符集将其解码为字符。 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 OutputStreamWriter类转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。 使用指定的字符集将字符编码为字节。 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。 序列化Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。 ObjectOutputStream类java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。 public ObjectOutputStream(OutputStream out) public final void writeObject(Object obj) 一个对象要想序列化，必须满足两个条件: 该类必须实现java.io.Serializable 接口 Serializable 是一个标记接口 对没有实现该接口的类，进行序列化反序列化会抛出NotSerializableException 。 该类的所有属性必须是可序列化的。 如果有一个属性不需要可序列化的，则该属性必须使用transient关键字注明是瞬态的。 ObjectInputStream类ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。 public final Object readObject () : 读取一个对象。 反序列化前提： 要能找到这个对象的class文件 找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。 序列化之后，class文件不能发生改变 发生改变，则会抛出一个InvalidClassException异常。 Serializable 接口给需要序列化的类，提供了一个版本序列号serialVersionUID 用于验证序列化的对象和对应类是否版本匹配。我们可以给它一个固定值，这样就不受该序列号的影响了 例子：序列化集合1234567891011121314151617181920212223242526272829303132public static void main(String[] args) throws Exception { // 创建 学生对象 Student student = new Student(\"老王\", \"laow\"); Student student2 = new Student(\"老张\", \"laoz\"); Student student3 = new Student(\"老李\", \"laol\"); ArrayList&lt;Student&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(student); arrayList.add(student2); arrayList.add(student3); // 序列化操作 // serializ(arrayList); // 反序列化 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"list.txt\")); // 读取对象,强转为ArrayList类型 ArrayList&lt;Student&gt; list = (ArrayList&lt;Student&gt;)ois.readObject(); for (int i = 0; i &lt; list.size(); i++ ){ Student s = list.get(i); System.out.println(s.getName()+\"--\"+ s.getPwd()); }}private static void serializ(ArrayList&lt;Student&gt; arrayList) throws Exception { // 创建 序列化流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"list.txt\")); // 写出对象 oos.writeObject(arrayList); // 释放资源 oos.close();} 打印流平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。 System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。 public PrintStream(String fileName)： 使用指定的文件名创建一个新的打印流。 例子：改变打印流 12System.setOut(new PrintStream(\"out.txt\"));System.out.println(\"hello world\"); // 打印到文件中","link":"/2020/05/01/Java/Java%20IO%E6%B5%81/"},{"title":"Java函数式编程","text":"Java函数式编程 函数式接口函数式接口在Java中是指：有且仅有一个抽象方法的接口（可以有非抽象方法）。函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。 @FunctionalInterface注解Java 8中专门为函数式接口引入了一个新的注解： @FunctionalInterface。该注解可用于一个接口的定义上。一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口。 1234@FunctionalInterfacepublic interface MyFunctionalInterface { void myMethod();} 函数式编程在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——强调做什么（What），而不是怎么做（How）。重视的是结果,而不是过程 Lambda表达式JDK8，必须具有函数式接口才能使用。如：Runnable、Comparator Lambda 标准格式 1(参数类型 参数名称) -&gt; { 代码语句 } Lambda省略格式 小括号内参数的类型可以省略； 如果小括号内有且仅有一个参，则小括号可以省略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。 Lambda表达式作为参数 如果方法的参数是一个函数式接口类型，那么就可以使用Lambda表达式进行替代。 123456789101112// 实现Runnable接口new Thread(() -&gt; { System.out.println(Thread.currentThread().getName());}).start();// 实现Comparator接口Student[] arr = new Student[] { new Student(\"aa\", 18), new Student(\"bb\", 16)};Arrays.sort(arr, (s1, s2) -&gt; s1.age - s2.age); Lambda表达式作为返回值 如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式。 12345678private static Comparator&lt;String&gt; newComparator() { return (a, b) ‐&gt; b.length() ‐ a.length();}public static void main(String[] args) { String[] array = { \"abc\", \"ab\", \"abcd\" }; Arrays.sort(array, newComparator());} Lambda的延迟有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以作为解决方案，提升性能。 性能浪费的日志案例 12345678910111213private static void log(int level, String msg) { if (level == 1) { System.out.println(msg); }}public static void main(String[] args) { String msgA = \"Hello\"; String msgB = \"World\"; String msgC = \"Java\"; // 无论level为多少都会进行字符拼接操作，但只有level=1时，字符串拼接才是有意义的 log(1, msgA + msgB + msgC);} 优化 SLF4J在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行字符串的拼接，而是将字符串的若干部分作为可变参数传入方法中，仅在日志级别满足要求的情况下才会进行字符串拼接。 例如： LOGGER.debug(&quot;变量{}的取值为{}。&quot;, &quot;os&quot;, &quot;macOS&quot;) Lambda方式 1234567891011121314151617181920212223interface MessageBuilder { String builderMessage();}public class DemoLambda { public static void main(String[] args) { String log1 = \"log1\"; String log2 = \"log2\"; String log3 = \"log3\"; // 只有当level等级为1时，才会调用builderMessage方法，进行字符串拼接 System.out.println(getMessage(1, () -&gt; log1 + log2 + log3)); } private static String getMessage(int level, MessageBuilder mb) { if (level == 1) { System.out.println(\"条件满足才执行\"); return mb.builderMessage(); } else { return null; } }} 常用函数式接口JDK提供了大量常用的函数式接口以丰富Lambda的典型使用场景, 主要在java.util.function 包中被提供。下面是最简单的几个接口及使用示例。 Supplier接口java.util.function.Supplier&lt;T&gt; 接口仅包含一个无参的方法： T get() 。用来获取一个泛型参数指定类型的对象数据。由于这是一个函数式接口，这也就意味着对应的Lambda表达式需要“对外提供”一个符合泛型类型的对象数据。 123456789public static void main(String[] args) { int a = 1; int b = 2; System.out.println(sum(() -&gt; a+b));}private static int sum(Supplier&lt;Integer&gt; sup) { return sup.get();} Consumer接口java.util.function.Consumer&lt;T&gt; 接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型决定。抽象方法 void accept(T t) ，意为消费一个指定泛型的数据。 默认方法：andThen 如果一个方法的参数和返回值有多个Consumer 类型，那么就可以实现：消费数据的时候，先组合， 再调用accept方法消费数据。 123456// andThen 源码default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) { // Objects.requireNonNull: 参数为null时主动抛出NullPointerException 异常 Objects.requireNonNull(after); return (T t) ‐&gt; { accept(t); after.accept(t); };} 例子 12345678910public static void main(String[] args) { show(\"AcBBsfasdf\", s -&gt; System.out.println(s.toUpperCase()), // 先转为大写 s -&gt; System.out.println(s.toLowerCase()) // 再转为小写 );}public static void show(String data, Consumer&lt;String&gt; s1, Consumer&lt;String&gt; s2) { s1.andThen(s2).accept(data);} Predicate接口有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用java.util.function.Predicate接口。 抽象方法： boolean test(T t) 。 默认方法：and、or、negate ， 对应与、或、非。 例子 12345678910111213141516171819202122public static void main(String[] args) { String[] arr = { \"迪丽热巴,女\", \"古力娜扎,女\", \"马尔扎哈,男\", \"赵丽颖,女\" }; // 选名字为3个字的女性 List list = FilterName(arr, name -&gt; name.split(\",\")[1].equals(\"女\"), name -&gt; name.split(\",\")[0].length() == 3 ); System.out.println(list);}private static List FilterName(String[] arr, Predicate&lt;String&gt; p1, Predicate&lt;String&gt; p2) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (String name : arr) { if (p1.and(p2).test(name)) { list.add(name.substring(0, 3)); } } return list;} Function接口java.util.function.Function接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。 抽象方法： R apply(T t) ，根据类型T的参数获取类型R的结果。 默认方法：andThen 用来进行组合操作。源码如下： 1234default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) { Objects.requireNonNull(after); return (T t) ‐&gt; after.apply(apply(t));} 例子: 将一个字符型的数字转为int型的，然后再计算这个数的乘方。 123456789public static void main(String[] args) { String num = \"99\"; int ret = getNumNum(num, s -&gt; Integer.parseInt(s), s -&gt; s * s); System.out.println(ret);}public static int getNumNum(String num, Function&lt;String, Integer&gt; f1, Function&lt;Integer, Integer&gt; f2) { return f1.andThen(f2).apply(num);} Stream流Java8引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端。 传统集合的多步遍历的弊端: 为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，而并不是从第一个到最后一个顺次处理的循环。前者是目的，后者是方式。 for循环的语法就是“怎么做” for循环的循环体才是“做什么” 流式思想流式思想类似与工厂车间的“生产流水线。当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先拼好一个“模型”步骤方案，然后再按照方案一步步的去执行它。 Stream流 是一个集合元素的函数模型，不是集合，也不是数据结构，其本身并不存储任何元素或者地址值 是一个来自数据源的元素队列，数据源可以是集合，数组 等。 Stream操作特征 Pipelining: 中间操作都会返回流对象。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。 内部迭代： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。 获取流java.util.stream.Stream 是Java 8新加入的最常用的流接口 所有的Collection集合都可以通过stream默认方法获取流； Stream接口的静态方法of可以获取数组对应的流。 public static &lt;T&gt; Stream&lt;T&gt; of(T... values) 例子 12345678910111213141516// Stream.of方法Stream&lt;String&gt; stream1 = Stream.of(\"aa\", \"bb\", \"cc\");// Map: key, value, entryMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();map.put(1, \"aa\");map.put(2, \"bb\");Set&lt;Integer&gt; keySet = map.keySet();Stream&lt;Integer&gt; stream2 = keySet.stream();Collection&lt;String&gt; values = map.values();Stream&lt;String&gt; stream3 = values.stream();Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entryset = map.entrySet();Stream&lt;Map.Entry&lt;Integer, String&gt;&gt; stream4 = entryset.stream(); 常用方法 延迟方法：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为延迟方法。） 终结方法：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持链式调用。本小节中，终结方法包括 count 和 forEach 方法。 映射：map &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);: 将流中的元素映射到另一个流中 逐一处理：forEach： 是一个终结方法 void forEach(Consumer&lt;? super T&gt; action); 过滤：filter Stream filter(Predicate&lt;? super T&gt; predicate); 函数返回false过滤 reduce操作 reduce(initialValue, accumulator) 例：实现累加操作 list.stream().reduce(0, (acc, e) -&gt; acc + e) 第一个参数0，是acc的初始值， acc记录每次计算的结果 统计个数：count： 是一个终结方法 long count(); 最大值/最小值：max / min 需要传递一个Comparator对象 取用前几个：limit Stream limit(long maxSize);: 对流进行截取，只取用前n个。 跳过前几个：skip Stream skip(long n);: 流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。 组合：concat static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) collect collect(Collectors.toList()), 可将流中数据存入一个list集合并返回 例子: 使用Stream流优化下面操作现在有两个 ArrayList 集合存储队伍当中的多个成员姓名，请依次进行以下若干操作步骤： 第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。 第一个队伍筛选之后只要前3个人；存储到一个新集合中。 第二个队伍只要姓张的成员姓名；存储到一个新集合中。 第二个队伍筛选之后不要前2个人；存储到一个新集合中。 将两个队伍合并为一个队伍；存储到一个新集合中。 根据姓名创建 Person 对象；存储到一个新集合中。 打印整个队伍的Person对象信息。 12345678910111213141516List&lt;String&gt; one = List.of(\"迪丽热巴\", \"宋远桥\" , \"苏星河\", \"石破天\", \"石中玉\", \"老子\", \"庄子\", \"洪七公\");List&lt;String &gt; two = List.of(\"古力娜扎\", \"张无忌\", \"赵丽颖\", \"张三丰\", \"尼古拉斯赵四\", \"张天爱\");Stream&lt;String&gt; stream1 = one.stream() .filter(name -&gt; name.length() == 3).limit(3);Stream&lt;String&gt; stream2 = two.stream() .filter(name -&gt; name.startsWith(\"张\")).skip(2);Stream&lt;String&gt; stream3 = Stream.concat(stream1, stream2);ArrayList&lt;Person&gt; person = new ArrayList&lt;&gt;();stream3.forEach(name -&gt; person.add(new Person(name)));System.out.println(person); 方法引用在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？ 方法引用符双冒号::为引用运算符，而它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。 如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式——它们都将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。 通过对象名引用成员方法如果一个类中已经存在一个能过实现我们功能的成员方法，直接引用即可。 1234567891011121314151617181920@FunctionalInterfaceinterface printAble { void print(String s);}class printUpper { // 将字符串转为大写再打印 public void printUpperCase(String s) { System.out.println(s.toUpperCase()); }}public class Demo1 { public static void main(String[] args) { printUpper obj = new printUpper(); print(\"hello world\", obj::printUpperCase); } public static void print(String s, printAble p) { p.print(s); }} 通过类名称引用静态方法如果已经存在了一个能过实现我们功能的静态方法，直接引用即可。 12345678910111213@FunctionalInterfaceinterface printAble { void print(String s);}public class Demo1 { public static void main(String[] args) { printString(\"hello world\", s -&gt; System.out.println(s)); printString(\"hello world\", System.out::println); // 引用java提供的函数 } public static void printString(String s, printAble p) { p.print(s); }} 通过super引用成员方法如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代。 Lambda表达式：() -&gt; super.父类方法 方法引用： super::父类方法 通过this引用成员方法如果需要引用的方法就是当前类中的成员方法，那么可以使用this::成员方法的格式来使用方法引用。 类的构造器引用由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用类名::new的格式表示。 Lambda表达式： name -&gt; new Person(name) 方法引用： Person::new 123456789101112131415@FunctionalInterfaceinterface PersonBuilder { Person buildPerson(String name);}public class ConStrucorRef { public static void main(String[] args) { printPersonName(\"tan\", (name -&gt; new Person(name))); printPersonName(\"tan\", Person::new); } public static void printPersonName(String name, PersonBuilder p) { System.out.println(p.buildPerson(name).getName()); }} 数组的构造器引用数组也是 Object 的子类对象，所以同样具有构造器，只是语法稍有不同。 Lambda表达式：length -&gt; new int[length] 方法引用：int[]::new 12345678910111213141516@FunctionalInterfaceinterface ArrayBuilder { int[] buildArray(int length);}public class ArrayConStructorRef { public static void main(String[] args) { int[] arr1 = createArray(10, (len) -&gt; new int[len]); int[] arr2 = createArray(10, int[]::new); System.out.println(arr1.length + \", \" + arr2.length); } public static int[] createArray(int length, ArrayBuilder arrb) { return arrb.buildArray(length); }}","link":"/2020/05/01/Java/Java%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"title":"Java反射机制","text":"Java反射机制 反射反射：就是将类的各个组成部分封装为其他对象，是框架设计的灵魂。我们在程序运行过程中，操作通过反射得到的对象，可以实现解耦，可以提高程序的可扩展性。 成员变量 –&gt; Field 构造方法 –&gt; Constructor 成员方法 –&gt; Method Java代码三个阶段源码阶段(包括字节码) –&gt; Class类对象阶段 –&gt; RunTime运行时阶段 源码到Class类对象这个过程就是反射 获取Class对象一个类字节码文件在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。 Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 类名.class：通过类名的属性class获取 多用于参数的传递 对象.getClass()：getClass()方法在Object类中定义着。 多用于对象的获取字节码的方式 例子 12345678910111213141516public class Person { private String name; public void eat(String food) { System.out.println(getName() + \"正在吃\" + food); } ...}// 获取Class对象Class cls1 = Class.forName(\"Demo15.reflect.Person\");Class cls2 = Person.class;Class cls3 = p.getClass();System.out.println(cls1 + \"\\n\" + cls2 + \"\\n\" + cls3); // cls1=cls2=cls3: class Demo15.reflect.Person Class对象常用方法 获取成员变量们 Field[] getFields() ：获取所有public修饰的成员变量 Field getField(String name) 获取指定名称的 public修饰的成员变量 Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 Field getDeclaredField(String name) 获取指定名称的成员变量 获取构造方法们 Constructor&lt;?&gt;[] getConstructors() Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 传入构造方法对应形参的Class对象。如：int.class, String.class Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) Constructor&lt;?&gt;[] getDeclaredConstructors() 获取成员方法们： Method[] getMethods() Method getMethod(String name, Class&lt;?&gt;... parameterTypes) Method[] getDeclaredMethods() Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) 获取类上注解： Annotation[] getAnnotations() &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) 获取全类名: String getName() Field对象 成员变量对象 设置值：void set(Object obj, Object value) 获取值: get(Object obj) 忽略访问权限修饰符的安全检查: setAccessible(true):暴力反射， 设置后访问权限修饰符不起作用 例子 123456Field[] fields = cls1.getDeclaredFields();fields[0].setAccessible(true); // 忽略访问权限修饰符的安全检查System.out.println(fields[0].getName());fields[0].set(p, \"tt\");System.out.println(p.getName()); Constructor对象 构造方法对象 T newInstance(Object... initargs): 创建一个对象 例子 123456789Constructor constructor = cls1.getConstructor(String.class);System.out.println(constructor);Object p2 = constructor.newInstance(\"tan2\"); // 有参System.out.println((Person)p2);Object p3 = cls1.getDeclaredConstructor().newInstance();// 空参((Person)p3).setName(\"tan3\");System.out.println((Person)p3); Method对象 成员方法对象 执行方法：Object invoke(Object obj, Object... args) 获取方法名称：String getName():获取方法名 123456789Method[] methods = cls1.getMethods();for (Method method : methods) { if (method.getName().equals(\"eat\")) { method.invoke(p, \"棒棒糖\"); // tt正在吃棒棒糖 method.invoke(p2, \"饭\"); // tan2正在吃棒棒糖 } else { System.out.println(method.getName()); }} 案例写一个”框架”，实现在不改变任何代码的前提下，通过改变配置文件，来创建任意类的对象，并且执行其中任意方法。 配置文件 12345# src/conf.propertiesClassName=Demo15.reflect.PersonPersonName=tanMethodName=eatEatFood=banana 代码 12345678910111213141516171819Properties prop = new Properties();// 获取配置文件中的内容ClassLoader classLoader = this.getClass().getClassLoader(); // 类加载器InputStream in = classLoader.getResourceAsStream(\"conf.properties\");prop.load(in);String ClassName = prop.getProperty(\"ClassName\");String PersonName = prop.getProperty(\"PersonName\");String MethodName = prop.getProperty(\"MethodName\");String EatFood = prop.getProperty(\"EatFood\");// 获取类对象Class cls = Class.forName(ClassName);// 创建对象Object p = cls.getConstructor(String.class).newInstance(PersonName);Method method = cls.getMethod(MethodName, String.class);method.invoke(p, EatFood); // tan正在吃banana","link":"/2020/05/03/Java/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"title":"Java基础","text":"Java基础、面向对象编程 Java基础Java环境变量1234JAVA_HOME=jdk安装路径JRE_HOME=jre安装路径PATH= .;%JAVA_HOME%\\bin;%JRE_HOME%\\binCLASSPATH=.;%JAVA_HOME%\\lib;%JRE_HOME%\\lib 数组1234567// 创建数组的三种方式int[] arr1 = new int[3];int[] arr2 = new int[]{1, 2, 3};int[] arr3 = {1, 2, 3};// 获取数组长度System.out.println(arr1.length); 变量变量分类： 成员变量：类变量(static)、实例变量 局部变量：形参，方法体、代码块中声明的变量 存储位置： 局部变量：栈 实例变量：堆 类变量：方法区 变量匹配原则： 就近原则 形参传递机制 基本数据类型：传递数据值，即创建一个新的变量，并传递数据值。 引用数据类型：传递引用，即创建一个引用变量，并传递引用的地址。 可变参数用于传递多个相同类型的参数，其实就是一个数组 如果形参还有其它参数，则可变参数必须放在参数列表的最后。 定义：修饰符 返回值类型 方法名(参数类型... 形参名) {} 例子：Arrays类的asList方法，就用到了可变参数。 123public static &lt;T&gt; List&lt;T&gt; asList(T... a) { return new ArrayList&lt;&gt;(a);} final 关键字 final： 不可改变。可以用于修饰类、方法和变量。 类：被修饰的类，不能被继承。 方法：被修饰的方法，不能被重写。 变量：被final修饰的变量只能被赋值一次，不能更改；若是引用类型则不可修改其引用。 123修饰符 final class 类名 {}修饰符 final 返回值类型 方法名(参数列表){}final 类型 var = vaule Jvm内存分区 栈（stack）: 存放局部变量， 方法运行时使用的内存 堆（Heap）: 存储对象或者数组，new来创建的，都存储在堆内存。 堆内存数据的默认值： 0, 0.0, ‘\\u0000’, false, null(引用) 方法区(Method Area): 存储已被虚拟机加载的类信息、常量、静态变量 本地方法栈: 为JVM使用native本地方法而准备的 程序计数器（Program Counter Register）：记录下一条jvm指令的执行地址 通过程序计数器，来恢复线程的正确执行位置 面向对象继承继承提高了代码的维护性、拓展性，但增加了代码的耦合度（更改父类代码可能会导致子类发生变化） 语法：class 子类名 extends 父类名 {} 注意： 私有成员可以会被子类继承，但对子类来说是不可见的 成员变量不能被覆盖：子类定义了父类中存在的变量，则类中会有两个变量，一个是子类的一个是父类 接口与抽象类定义接口 12345678910111213public interface 接口名称 { // 成员变量：是一个常量, 定义时必须赋值 [public static final] 数据类型 常量名 = 数据值; // 抽象方法 [public abstract] void method(); // 默认方法： 解决接口升级的问题， 可以被实现类重写 [public] default void method() {} // 静态方法 [public] static void method() {} // 私有方法：解决多个默认/静态方法中的代码重复的问题，不能被接口的实现类使用 private void void method() {} private static void method() {}} 定义抽象类 1234修饰符 abstract class 类名 { // 抽象方法 修饰符 abstract 返回值类型 方法名 (参数列表)； } 接口与抽象类的区别 接口的方法默认是 public，所有方法在接口中不能有实现(jdk8 可以有默认方法和静态方法，jdk9可以有私有方法 ），而抽象类可以有非抽象的方法。 接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。 接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。 注意： 接口没有静态代码块和构造方法 类与类之间是单继承的，类与接口之间时多实现的，接口与接口之间是多继承的 实现多个接口，发生默认方法冲突时，必须要实现该默认方法 父类继承的方法与实现的接口的默认方法冲突，子类优先使用父类继承的方法 多态父类类型作为方法形参，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。 多态中的转型 向上转型：子到父（安全） 左边可以对象、也可以是接口 弊端：不能访问子类特有的方法，需要向下转型 向下转型：父到字（加强制转换） 使用instanceof判断对象是由哪个类实例化的 123if (对象 instanceof 类) { System.out.println(\"是\");} 重写Override 不能被重写的方法 final方法 静态方法 子类中不可见方法，如私有方法 对象的多态性 子类重写了父类的方法，通过子类对象调用的一定子类重写过的方法。 非静态方法默认调用对象是this， 而this对象在构造器或者说是&lt;init&gt;方法中指的是正在创建的对象。 如：创建子类对象时，调用父类&lt;init&gt;方法，此方法中的this对象就是这个正在的子类对象。 类初始化 创建实例对象前需要先加载并初始化类 main方法所在的类需要先加载和初始化 初始化字类前需要初始化父类 类的初始化就是执行&lt;clinit&gt;()方法， 只执行一次 &lt;clinit&gt;方法由静态类变量显示赋值代码和静态代码块组成，先后顺序由类中代码顺序决定。 实例初始化 实例初始化就是执行&lt;init&gt;()方法 每次创建实例，都会调用构造器对应的&lt;init&gt;方法。 &lt;init&gt;方法首行是super方法，即执行父类的&lt;init&gt;方法。 然后是实例变量显示赋值代码和非静态块，顺序取决与类中代码的顺序。 最后是对应的构造器代码。 内部类将一个类定义在另一个类里面。在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。 内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的class文件,文件名外部类$内部类.class 成员内部类将一个类定义在另一个类里面，方法外。 1234class 外部类 { class 内部类{ }} 内部类可以直接访问外部类的成员，包括私有成员。 外部类要访问内部类的成员，必须要建立内部类的对象。 1外部类名.内部类名 对象名 = new 外部类型().new 内部类型()； 访问外部类同名变量：外部类名.this.外部变量名 静态内部类将一个静态类定义在另一个类里面，方法外。 特点： 不会随着外部类加载而加载，要在用到的时候才会单独加载 外部类中，可以通过内部类名.的方式访问内部类成员，包括私有的 局部内部类将一个类定义在另一类的方法中。若内部类需要访问方法所在的局部变量，那么这个局部变量必须是常量。因为方法运行结束后，局部变量就会消失，而在方法中new出来的对象不会立刻消亡。 1234567891011public class Outer { public class method() { int num = 10; // 必须是final的，JDK8后final可省略 class Inner { System.out.println(num); }； new Inner(). }} 匿名内部类匿名内部类 ：是内部类的简化写法。它的本质是一个 带具体实现的 父类或者父接口的匿名的子类对象。 匿名对象只能在创建对象时使用一次，而 匿名内部类不是。 匿名内部类必须继承一个父类或者实现一个父接口 123456789父类名或者接口名 obj new 父类名或者接口名() { // 方法重写 @Override public void method() {}};obj.method();// 匿名对象new 父类名或者接口名() {...}.method(); 包装类Byte, Short, Integer, Long, Float, Double, Character, Boolean 装箱拆箱 装箱：从基本类型转换为对应的包装类对象。 拆箱：从包装类对象转换为对应的基本类型。 使用包装类中的valueof方法 12Integer a = new Integer(4); // 装箱Integer b = Integer.valueOf(4); // 拆箱 自动装箱/自动拆箱 (JDK 1.5) 12Integer i = 1 // 自动装箱i = i + 1 // 先拆箱，再装箱 缓存机制当使用自动装箱的时候，就会触发Java的缓存机制。这个时候java虚拟机会创建一系列的整数并且缓存到一个数组中以便直接使用，这就是缓存策略。 Byte，Short，Long 有固定范围: -128 到 127。 对于 Character, 范围是 0 到 127。 Long源码 123456789101112131415161718public static Long valueOf(long l) { final int offset = 128; if (l &gt;= -128 &amp;&amp; l &lt;= 127) { // will cache return LongCache.cache[(int)l + offset]; } return new Long(l);}private static class LongCache { private LongCache(){} static final Long cache[] = new Long[-(-128) + 127 + 1]; static { for(int i = 0; i &lt; cache.length; i++) cache[i] = new Long(i - 128); }} 字符串转基本类型除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型 如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。 public static byte parseByte(String s)：string – &gt; byte public static short parseShort(String s)：string –&gt; short public static int parseInt(String s)：string –&gt; int public static long parseLong(String s)：string –&gt; long public static float parseFloat(String s)：string –&gt; float public static double parseDouble(String s)：string –&gt; double public static boolean parseBoolean(String s)：string –&gt; boolean 123String s1 = \"123\";byte b = Byte.parseByte(s1);System.out.println(b); // 123 基础类型转字符串 使用’+’： 基础类型 + “” 包装类的静态方法tostring String类的静态方法valueof(), 传入任意类型 常用类Scanner 类一个可以解析基本类型和字符串的简单文本扫描器 123Scanner sc = new Scanner(System.in);int i = sc.nextInt();String s = sc.next(); Random 类此类的实例用于生成伪随机数。 12Random rand = new Random();int num = rand.nextInt(10); // [0, 10) ArrayList 类ArrayList对象不能存储基本类型，只能存储引用类型的数据 public boolean add(E e) ：将指定的元素添加到此集合的尾部 public E remove(int index) ：移除此集合中指定位置上的元素 public E get(int index) ：返回此集合中指定位置上的元素 public int size() ：返回此集合中的元素数 String 类String 类代表字符串。字符串是常量，它们的值在创建之后不能更改，底层是一个被final修饰的字节数组。 public int length () ：返回此字符串的长度。 public String concat (String str) ：将指定的字符串连接到该字符串的末尾。 public char charAt (int index) ：返回指定索引处的 char值。 public int indexOf (String str) ：返回指定字符串第一次出现在该字符串内的索引。 public String substring (int beginIndex) ：从beginIndex开始截取字符串到字符串结尾。 public String substring (int beginIndex, int endIndex) ：含beginIndex，不含endIndex。 public String[] split(String regex) ：将此字符串按照给定的规则拆分为字符串数组。 public boolean endsWith(String suffix)： 测试此字符串是否以指定的后缀结束。 public boolean StartsWith(String prefix)： 测试此字符串是否以指定的前缀开始。 public boolean matches(String regex) : 正则匹配 replace replaceAll intern()：从常量池中找与这个字符串相等的串，找到则返回，无则在池中新建 Arrays 类java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法， public static String toString(int[] a) ：数组转字符串 public static void sort(int[] a) ：按升序进行排序 public static T[] copyOf(T[] original, int newLength)：返回一个新数组 Math 类java.lang.Math 类包含用于执行基本数学运算的方法, 其所有方法均为静态方法 public static double abs(double a) ：返回 double 值的绝对值。 public static double ceil(double a) ：返回大于等于参数的最小的整数。 public static double floor(double a) ：返回小于等于参数最大的整数。 public static long round(double a) ：返回最接近参数的 long。(相当于四舍五入方法) Object 类java.lang.Object类是Java语言中的根类，即所有类的父类。 tostring 方法 public String toString()：返回该对象的字符串表示。 默认该字符串内容就是对象的类型+@+内存地址值。 equals 方法 public boolean equals(Object obj)：比较其他某个对象是否与此对象“相等”。 不能容忍空指针， 容易抛出空指针异常 默认为地址比较 如果没有覆盖重写equals方法，那么Object类中默认进行==运算符的对象地址比较，只要不是同一个对象，结果必然为false。 对象内容比较 如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。 hashCode 方法hashCode方法返回对象的哈希值，是一个十进制整数，由系统随机给出（实际上就是对象的逻辑地址值）。 哈希冲突：两个元素不同，但有相同的哈希值。 Objects 类java.util.Objects类, 是JDK7中添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的）。 Date 类java.util.Date类 表示特定的瞬间，精确到毫秒。 Date对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。 public Date()：使用无参构造，可以自动设置当前系统时间的毫秒时刻 public Date(long date)：指定long类型的构造参数，可以自定义毫秒时刻。 public long getTime() 把日期对象转换成对应的时间毫秒值。 Date类对Object类中的toString方法进行了覆盖重写， 返回一个时间字符串(Thu Jan 01 08:00:00 CST 1970) DateFormat 类java.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。常用的子类java.text.SimpleDateFormat。 public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat对象。 参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则: 年月日时分秒 – y M d H m s 1DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); public String format(Date date)：将Date对象格式化为字符串。 public Date parse(String source)：将字符串解析为Date对象。 练习：计算一个人已经出生了多少天 12345678910111213System.out.println(\"请输入出生日期(yyyy-MM-dd): \");String birthdayString = new Scanner(System.in).next();DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");Date birthdayDate = df.parse(birthdayString);Date currentDate = new Date();long delta = currentDate.getTime() - birthdayDate.getTime();if (delta &lt; 0) { System.out.println(\"尚未出生!\");} else { System.out.println(\"已出生\" + delta / (1000*60*60*24) + \"天\");} Calendar类java.util.Calendar是日历类, 是一个抽象类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。 public static Calendar getInstance()：使用默认时区和语言环境获得一个日历， 是Calendar子类的一个静态方法 1Calendar cal = Calendar.getInstance(); public int get(int field)：返回给定日历字段的值。 日历字段(field) 含义 YEAR 年 MONTH 月（从0开始，一月为0） DAY_OF_MONTH / DATE 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（从周日开始，周日为1） public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 注意： 西方星期的开始为周日，中国为周一。 Calendar类中，月份的表示是以0-11代表1-12月 日期是有大小关系的，时间靠后，时间越大。 System 类java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作。 public static long currentTimeMillis()：返回以毫秒为单位的当前时间 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 src， dest: 源数组， 目标数组 srcPos, destPos: 源数组，目标数组起始位置索引 length: 复制元素个数 StringBuilderjava.lang.StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。它的内部拥有一个数组用来存放字符串内容，进行字符a串拼接时，直接在数组中加入新内容。(默认16字符空间，超过自动扩充) stringBuilder单线程使用， stringBuffer多线程使用 public StringBuilder()：构造一个空的StringBuilder容器。 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。 public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 Collection 集合java.util.Collection是单列集合类的根接口，有两个重要的子接口，分别是java.util.List和java.util.Set。 List的特点是元素有序、元素可重复。 实现类有java.util.ArrayList和java.util.LinkedList， Set的特点是元素无序，而且不可重复。 主要实现类有java.util.HashSet和java.util.TreeSet。 Collection集合通用操作 public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。 public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 List 集合java.util.List接口继承自Collection接口，是单列集合的一个重要分支。 特点：有序、可重复。 ArrayList 集合java.util.ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快。 public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 LinkedList 集合java.util.LinkedList集合数据存储的结构是链表结构， 是一个双向链表。元素增删快，查找慢。 在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。 public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst():返回此列表的第一个元素。 public E getLast():返回此列表的最后一个元素。 public E removeFirst():移除并返回此列表的第一个元素。 public E removeLast():移除并返回此列表的最后一个元素。 public E pop():从此列表所表示的堆栈处弹出一个元素。 public void push(E e):将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回true。 Vector 集合Vector是最早期的集合，是同步的，现在基本不再使用。 Set 集合java.util.Set接口和java.util.List接口一样，同样继承自Collection接口。 与List不同的是，Set元素无序，不能重复。 HashSet 集合java.util.HashSet是Set接口的一个实现类，HashSet底层的是一个java.util.HashMap。 HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。 如何保证元素唯一的：hashCode与equals方法 先比较哈希值，相同再使用equals方法比较。 所以使用哈希表存储自定义类型时，必须要重写hashCode和equals方法 LinkedHashSetjava.util.LinkedHashSet也是Set接口的实现类。 与HashSet的不同在于增加了一个链表，用来存储元素存储的顺序。 Iterator迭代器Iterator接口也是Java集合中的一员，主要用于迭代访问（即遍历）Collection中的元素。 迭代：Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，如果还有就再取出出来。一直把集合中的所有元素全部取出。 操作 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 public E next():返回迭代的下一个元素。 集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException 123456789Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();coll.add(\"aaa\");coll.add(\"bbb\");coll.add(\"ccc\");Iterator iter = coll.iterator();while (iter.hasNext()) { System.out.println(iter.next());} for-each循环JDK1.5，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能进行增删操作。 格式 1for(元素的数据类型 变量 : Collection集合or数组) {} 例子 123for (String s : coll) { System.out.println(s);} Map 集合java.util.Map中的集合，元素是成对存在。每个元素由键（key唯一）与值两部分组成，通过键可以找对所对应的值。需要重写键的hashCode()方法、equals()方法。 public V put(K key, V value): 把指定的键与值添加到Map集合中。 key不重复，返回null; key重复更新value，返回原来的value public V remove(Object key): 把指定的键元素删除，返回被删除元素的值。 public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 boolean containsKey(Object key) 判断集合中是否包含指定的键。 public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 Map.Entry：Map中的一对键和值又称做Map中的一个Entry(项)。Entry将键值对的对应关系封装成了对象。即键值对对象。 getKey()：获取键值对的key getValue()：获取键值对的value HashMap / LinkedHashMapHashMap&lt;k, v&gt; 和 LinkedHashMap&lt;k, v&gt;是Map下重要的两个子类。具体实现可类比Set接口的子类HashSet和LinkedHashSet。 可以存储&lt;null, null&gt; HashtableHashtable和Vector集合一样，在jdk1.2后被取代了，但其子类Properties集合依然活跃在历史的舞台。Properies是一个唯一与IO流相结合的集合。 同步单线程， 底层是一个哈希表 Hashtable 不能存储&lt;null, null&gt; 遍历Map集合键找值的方式： 12345678910111213141516Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();map.put(1, \"张三\");map.put(2, \"李四\");// for-each 遍历for (Integer key : map.keySet()) { System.out.println(\"[\" + key + \", \" + map.get(key) + \"]\");}// 手工遍历Set&lt;Integer&gt; keySet = map.keySet();Iterator iter = keySet.iterator();while (iter.hasNext()) { Integer key = (Integer) iter.next(); System.out.println(\"[\" + key + \", \" + map.get(key) + \"]\");} 键值对方法是：使用Map.Entry对象遍历 123for (Map.Entry&lt;Integer, String&gt; m : map.entrySet()) { System.out.println(\"[\" + m.getKey() + \", \" + m.getValue() + \"]\");} 案例：统计每个字符出现的次数123456789101112131415String s = \"aaaBBBBBBBCCcccccddd\";// key：字符， value：字符出现的次数Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();for (int i = 0; i &lt; s.length(); ++i) { char c = s.charAt(i); if (map.containsKey(c)) map.put(c, map.get(c) + 1); else map.put(c, 1);}for (Character c : map.keySet()) { System.out.println(c + \": \" + map.get(c));} 泛型在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。 泛型是一种未知类型。在创建对象时确定具体的类型，没有指定泛型时默认为Object类型。 泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。 泛型类语法：修饰符 class 类名&lt;代表泛型的变量&gt; {} 12345678class ArrayList&lt;E&gt;{ public boolean add(E e){ } public E get(int index){ } ....}// 创建对象时确定泛型ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 泛型方法语法：修饰符 interface接口名&lt;代表泛型的变量&gt; {} 12345678public class Demo { public &lt;E&gt; void show(E e) { return e; }}// 调用方法时确认泛型的类型String s = new Demo().show(\"hello world\") 泛型接口语法：修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数) {} 1234567891011public interface MyGenericInterface&lt;E&gt;{ public abstract void add(E e); public abstract E getE(); }// 1. 定义类时确定泛型的类型public class MyImp1 implements MyGenericInterface&lt;String&gt; {}// 2. 始终不确定泛型的类型，直到创建对象时，确定泛型的类型public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; {}MyImp2&lt;String&gt; obj = new MyImp2&lt;&gt;(); 泛型通配符当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。也就是说只能接受数据，不能往该集合中存储数据。 为什么不用&lt;Object&gt; 因为泛型不存在继承关系, Collection&lt;Object&gt; list = new ArrayList&lt;String&gt;()这种是错误的。 12345678void showList(ArrayList&lt;Object&gt; list) {} // 只能接受List&lt;Object&gt;类型的void showList(ArrayList&lt;?&gt; list) {} // 接受任意ListList&lt;String&gt; list1 = new ArrayList&lt;&gt;();list1.add(\"hello\");List&lt;?&gt; list2 = list1; // 接受list1, 但不能使用list2往该集合中存放数据list2.add(\"world\"); // error 高级用法 – 受限泛型 泛型的上限 格式： 类型名称 &lt;? extends T&gt; coll 意义： 用于接收T及其子类， 不能添加数据，用于读取操作。如：coll.get(0) 泛型的下限： 格式： 类型名称 &lt;? super T&gt; 对象名称 意义： 用于取出T及其父类型，可以添加数据。如：coll.add(new T) Collections 工具类java.utils.Collections是集合工具类，用来对集合进行操作。 常用方法 public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。 public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序（升） 不可直接进行比较的类型，需要实现comparable接口，重写compareTo方法 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 需要实现java.util.Comparator接口(比较器), 重写比较方法 1int compare(T o1, T o2) {} 然后再将new出来的比较器对象传给sort方法 Comparable和Comparator的区别 Comparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序。 Comparator：强行对某个对象进行整体排序。可以将Comparator 传递给sort方法，从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。 jdk9 新特性Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。 注意 of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如 HashSet，ArrayList等 Set， Map接口在调用of方法时，不能由重复元素 修改of()方法返回的集合，会报java.lang.UnsupportedOperationException异常 例子 123List&lt;Integer&gt; list = List.of(1, 2, 3, 4, 5); // 返回的list是不可变的Set&lt;Integer&gt; set = Set.of(1, 2, 3, 4, 5);Map&lt;Integer, String&gt; map = Map.of(1, \"a\", 2, \"b\");","link":"/2020/05/01/Java/Java%E5%9F%BA%E7%A1%80/"},{"title":"Java异常","text":"异常概念、异常处理、自定义异常 异常异常 ：程序执行过程中，出现非正常情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。 异常机制其实是帮助我们找到程序中的问题。 Java处理异常的方式是中断处理。 异常体系异常的根类是java.lang.Throwable 其下有两个子类：java.lang.Error与java.lang.Exception。 Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。 Exception: 也就是我们通常所说的异常，是必须要处理的。 Throwable中的常用方法： public void printStackTrace(): 打印异常的详细信息。包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage(): 获取发生异常的原因。 public String toString(): 获取异常的类型和异常描述信息(不用)。 异常分类 编译时期异常: checked异常。在编译时期,就会检查，如果没有处理异常,则编译失败。如日期格式化异常 运行时期异常: runtime异常。在运行时期检查异常，在编译时期运行异常不会编译器检测。如数学异常 我们可以不处理，默认交给JVM处理(打印异常，中断程序)。 异常处理Java异常处理的五个关键字：try、catch、finally、throw、throws 异常可传递，只要没有处理就会一直传递到调用处。 抛出异常throwthrow关键字，用来抛出一个指定的异常对象。将这个异常对象传递到调用者处，并结束当前方法的执行。 格式：throw new 异常类名(参数); 例如：Objects非空判断 12345public static &lt;T&gt; T requireNonNull(T obj) { if (obj == null) throw new NullPointerException(); return obj;} 声明异常throws关键字throws运用于方法声明之上, 用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常) 格式：修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2… {} 捕获异常try-catchJava中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 格式 123456789try{ 编写可能会出现异常的代码}catch(异常类型 e){ 处理异常的代码 //记录日志/打印异常信息/继续抛出异常} finally { 做一些善后工作，如关闭打开的资源 // finally中的代码一定会被执行} 异常注意事项 多个异常一次捕获，多次处理。 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 try/catch中有return语句，先执行语句但不返回，等finally中代码执行后返回 finally有return语句, 永远返回finally中的结果， 要避免。 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是抛出父类异常的子类或者不抛出异常。 自定义异常Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。 自定义异常类名一半以Exception结尾，表示该类是一个异常类 自定义异常必须继承Exception或者RuntimeException类 异常类中添加一个空参构造，调用父类的空参构造 异常类中添加一个带异常信息的构造方法， 调用父类的带异常信息的构造方法 例子 12345678910111213141516171819class registerException extends Exception { public registerException() { super();} public registerException(String message) { super(message); } public static void main(String[] args) throws registerException{ List&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, \"aa\", \"bb\", \"cc\"); String elem = new Scanner(System.in).next(); for (String s : list) { if (elem.equals(s)) { throw new registerException(\"该元素已经存在!\"); } } list.add(elem); System.out.println(list); }} try-with-resouceJDK7优化后的try-with-resource 语句，该语句确保了每个资源在语句结束时关闭。 所谓的资源（resource）是指在程序完成后，必须关闭的对象。 JDK7格式 12345try (创建资源对象的语句，如果多个,使用';'隔开) { // 读写数据} catch (Exception e) { e.printStackTrace();} JDK9改进: 可以引入对象, 被引入的对象，同样会被关闭。 12345try (资源对象1; 资源对象2; ...) { // 读写数据} catch (Exception e) { e.printStackTrace();}","link":"/2020/05/01/Java/Java%E5%BC%82%E5%B8%B8/"},{"title":"Java注解","text":"Java注解，也叫元数据，是jdk1.5引入的。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，是给计算机看的，不是程序的一部分。其本质上就是一个继承Annotation接口的接口。 作用分类 编写文档：通过代码里标识的注解生成文档 代码分析：通过代码里标识的注解对代码进行分析 编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查。如：@Override 自定义注解格式： 1234元注解public @interface 注解名称{ 属性列表;} 属性：接口中的抽象方法 属性的返回值类型： 基本数据类型 String 枚举 注解 以上类型的数组， 使用{}表示 定义了属性后，在使用注解时需要赋值 使用default给属性默认初始化值的，可以不进行属性的赋值 如果只有一个value属性需要赋值，则value可以省略，直接定义值即可。 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略 元注解：用于描述注解的注解 @Target：描述注解能够作用的位置 @Target(ElementType.TYPE): 被其注解的注解只能注解在类上 ElementType取值： TYPE：类上 METHOD：方法上 FIELD：成员变量上 @Retention：描述注解被保留的阶段 SOURCE, CLASS, RUNTIME @Retention(RetentionPolicy.RUNTIME) @Documented：描述注解是否被javadoc抽取到api文档中 @Inherited：描述注解是否被子类继承 使用该注解的类，若有子类，子类同样会继承该注解 获取注解的属性值 获取注解的子类实现对象 public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)： 该方法类对象，成员函数对象，成员变量对象都可调用 获取指定注解属性值 使用获取到的对象调用注解中定义的抽象方法。 练习 定义注解 123456@Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation { String info() default \"info\"; String value();} 测试 12345678910111213@MyAnnotation(\"嘻嘻\")public class AnnotationTest { @Test public void testAnnotation() { Class&lt;AnnotationTest&gt; clazz = AnnotationTest.class; MyAnnotation anno = clazz.getAnnotation(MyAnnotation.class); if (anno != null) { System.out.println(anno.info()); System.out.println(anno.value()); } }}","link":"/2020/05/07/Java/Java%E6%B3%A8%E8%A7%A3/"},{"title":"Json序列化与反序列化","text":"Json序列化与反序列化 Jackson常见的json解析器：Jsonlib，Gson，fastjson，jackson。我们这里用jackson 导入jackson的相关jar包 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.2&lt;/version&gt;&lt;/dependency&gt; 使用Jackson核心对象 ObjectMapper完成转换 反序列化：JSON转为Java对象 readValue(json字符串数据, Class) 复杂Class可以使用new TypeReference&lt;Class&gt;(){}; 序列化：Java对象转换JSON字符串 writeValueAsString(obj) writeValue(File，obj) writeValue(Writer，obj) writeValue(OutputStream，obj) 常用注解 @JsonIgnore：排除属性（不序列化该属性）。 @JsonFormat：格式化属性值 12@JsonFormat(pattern = \"yyyy-MM-dd\")private Date birthday; 例子 pojo 1234567891011@Data@NoArgsConstructor@AllArgsConstructorpublic class Goods { private Long skuId; private String title; private Long price; @JsonFormat(pattern = \"yyyy-MM-dd hh:mm\") private Date createTime;} test 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950ObjectMapper objectMapper = new ObjectMapper();// 序列/反序列一个普通pojo对象@Testpublic void testObject() throws JsonProcessingException { Goods goods = new Goods(1L, \"一加6\", 11110L, new Date()); // 序列化 String goodsJson = objectMapper.writeValueAsString(goods); System.out.println(\"goodsJson = \" + goodsJson); // 反序列化 Goods g = objectMapper.readValue(goodsJson, Goods.class); System.out.println(\"g = \" + g);}// 序列/反序列一个集合@Testpublic void testList() throws JsonProcessingException { ArrayList&lt;Goods&gt; goodsList = new ArrayList&lt;&gt;(); goodsList.add(new Goods(1L, \"一加6\", 11110L, new Date())); goodsList.add(new Goods(2L, \"一加7\", 2222220L, new Date())); // 序列化 String json = objectMapper.writeValueAsString(goodsList); System.out.println(\"json = \" + json); // 反序列化 List list = objectMapper.readValue(json, new TypeReference&lt;List&lt;Goods&gt;&gt;() { }); System.out.println(\"list = \" + list);}// 序列/反序列一个map@Testpublic void testMap() throws JsonProcessingException { HashMap&lt;Integer, Goods&gt; map = new HashMap&lt;&gt;(); map.put(1, new Goods(1L, \"一加6\", 11110L, new Date())); map.put(2, new Goods(2L, \"一加7\", 2222220L, new Date())); // 序列化 String json = objectMapper.writeValueAsString(map); System.out.println(\"json = \" + json); // 反序列化 Map&lt;Integer, Goods&gt; goodsMap = objectMapper.readValue(json, new TypeReference&lt;Map&lt;Integer, Goods&gt;&gt;() { }); System.out.println(\"goodsMap = \" + goodsMap);}","link":"/2020/05/01/Java/Json%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"Java文件操作","text":"File、FileFilter File 类java.io.File 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。 构造方法 public File(String pathname) ：将给定的路径名字符串转换为抽象路径名来创建 File实例。 public File(String parent, String child) ：parent + child = pathname public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建 File实例。 获取功能的方法 public String getAbsolutePath() ：返回此File的绝对路径名字符串。 public String getPath() ：将此File转换为路径名字符串。 public String getName() ：返回由此File表示的文件或目录的名称。 public long length() ：返回由此File表示的文件的长度。 但是File对象表示目录，则返回值未指定。 判断功能的方法 public boolean exists() ：此File表示的文件或目录是否实际存在。 public boolean isDirectory() ：此File表示的是否为目录。 public boolean isFile() ：此File表示的是否为文件。 创建删除功能的方法 public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 public boolean delete() ：删除由此File表示的文件或目录。 public boolean mkdir() ：创建由此File表示的目录。 public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。 目录遍历 public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。 public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 例子: 递归遍历目录 123456789101112private static void tree(File dir) { if (dir == null) return; File[] files = dir.listFiles(); for (File file : files) { if (file.isFile()) { System.out.println(file.getPath()); } else { tree(file); } }} 文件过滤器java.io.FileFilter函数式接口，是File的过滤器。 该接口中的方法：boolean accept(File pathname) 该接口的对象可以传递给File类的listFiles 方法。 listFiles(FileFilter) 方法 对目录进行遍历，获取目录中的每一文件/文件夹，并将它们封装成File对象 调用形参FileFilter对象中的accept方法， 并传入遍历得到的每一个File对象 accept方法返回true，则将该File对象放入File[]数组中。 例子: 找出指定目录下的所有.java文件 123456789101112private static void findJavaFile(File dir) { File[] files = dir.listFiles(file -&gt; { file.getName().endsWith(\".java\") || file.isDirectory(); }); for (File file : files) { if (file.isFile()) System.out.println(file.getPath()); else findJavaFile(file); }}","link":"/2020/05/01/Java/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"title":"SpringBoot集成Thymeleaf","text":"Thymeleaf语法、页面静态化 ThymeleafThymeleaf是用来开发web和独立环境项目的现代服务器端Java模板引擎。 动静结合：Thymeleaf再有网无网络的环境下皆可运行 开箱急用，多方言支持 与SpringBoot完美整合 视图解析ThymeleafViewResolver， 与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置 1234567@ConfigurationProperties(prefix = \"spring.thymeleaf\")public class ThymeleafProperties { /* 默认前缀 */ public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; /* 默认后缀 */ public static final String DEFAULT_SUFFIX = \".html\";} 页面缓存Thymeleaf默认会开启网页缓存，提高页面的并发能力，但会导致我们修改页面不会立即被展现。所以我们在开发中需要先禁用缓存： 1spring.thymeleaf.cache=false # 设置为不缓存 注意：在idea中，禁用缓存后，每次修改页面，还需要recompile一下页面，才能在刷新网页。 快速入门 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; HelloContorller.java 123456789101112@Controllerpublic class HelloController { @GetMapping(\"hello\") public ModelAndView hello() { ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\", \"hello thymeleaf!\"); mv.setViewName(\"hello\"); return mv; }} hello.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2 th:text=\"${msg}\"&gt;hello world&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 访问该controller的地址，即可看到渲染结果 语法${} @{} || ${} ：变量表达式，获取Model中的变量值，ognl的语法。 @{}：url表达式 @{/user(id=1)}： /user?id=1 ||：双竖线中可以有普通字符串，也可以有变量表达式 |page-item ${page=1 ? 'disabled' : ''}| th:text / th:utest th:text 读到的值会格式化输出，可以防止HTML注入 th:utest 输出原始内容，可以渲染html代码 字面量 字符串字面量：使用单引号引起来 数字字面量：数字不需要任何特殊语法， 写的什么就是什么 布尔字面量：true / false 自定义变量频繁的使用${user.}来获取属性值会非常麻烦，因此Thymeleaf通过自定变量来解决这个问题 再div标签上使用th:object=”${user}”获取user的值，并保存下来 然后在该标签内部任意元素上，通过*{属性名}的方式，来获取对象中的属性值 12345&lt;h2&gt;User&lt;/h2&gt;&lt;div th:object=\"${user}\"&gt; &lt;h3&gt;username: &lt;span th:text=\"*{username}\"&gt;username&lt;/span&gt;&lt;/h3&gt; &lt;h3&gt;password: &lt;span th:text=\"*{password}\"&gt;password&lt;/span&gt;&lt;/h3&gt;&lt;/div&gt; 运算支持算术运算、比较运算、条件运算。 需要注意：${}内部的是通过OGNL表达式引擎解析的，外部的才是通过Thymeleaf的引擎解析，因此运算符尽量放在${}外进行。 逻辑判断 th:if / th:else th:switch / th:case：一旦有一个th:case成立，其它的则不再判断 12345&lt;div th:switch=\"${user.role}\"&gt; &lt;p th:case=\"'admin'\"&gt;用户是管理员&lt;/p&gt; &lt;p th:case=\"'manager'\"&gt;用户是经理&lt;/p&gt; &lt;p th:case=\"*\"&gt;用户是别的玩意&lt;/p&gt;&lt;/div&gt; th:each循环遍历12345&lt;!-- stat循环状态对象 --&gt;&lt;p th:each=\"user, stat : ${users}\"&gt; 姓名：&lt;span th:text=\"${user.name}\"&gt;&lt;/span&gt; 年龄：&lt;span th:text=\"${user.age}\"&gt;&lt;/span&gt;&lt;/p&gt; 可以遍历一下类型： Iterable，实现了Iterable接口的类 Enumeration，枚举 Interator，迭代器 Map，遍历得到的是Map.Entry Array，数组及其它一切符合数组结果的对象 stat对象包含以下属性： index，从0开始的角标 count，元素的个数，从1开始 size，总元素个数 current，当前遍历到的元素 even/odd，返回是否为奇偶，boolean值 first/last，返回是否为第一或最后，boolean值 方法ognl表达式本身就支持方法调用，如： 12&lt;!-- 调用string的split方法 --&gt;&lt;span th:text=\"${user.name.split(' ')[0]}\"&gt;Jack&lt;/span&gt; 内置对象Thymeleaf中提供了一些内置对象，并且在这些对象中提供了一些方法，方便我们来调用。获取这些对象，需要使用#对象名来引用。 一些环境相关对象 对象 作用 #ctx 获取Thymeleaf自己的Context对象 #requset 如果是web程序，可以获取HttpServletRequest对象 #response 如果是web程序，可以获取HttpServletReponse对象 #session 如果是web程序，可以获取HttpSession对象 #servletContext 如果是web程序，可以获取HttpServletContext对象 Thymeleaf提供的全局对象： 对象 作用 #dates 处理java.util.date的工具对象 #calendars 处理java.util.calendar的工具对象 #numbers 用来对数字格式化的方法 #strings 用来处理字符串的方法 #bools 用来判断布尔值的方法 #arrays 用来护理数组的方法 #lists 用来处理List集合的方法 #sets 用来处理set集合的方法 #maps 用来处理map集合的方法 例子：显示当前日期 1&lt;h2 th:text=\"${#dates.format(#dates.createNow(), 'yyyy-MM-dd')}\"&gt;&lt;/h2&gt; js模板模板引擎不仅可以渲染html，也可以对JS中的进行预处理。而且为了在纯静态环境下可以运行，其Thymeleaf代码可以被注释起来： 123456&lt;script th:inline=\"javascript\"&gt; const user = /*[[${user}]]*/ {}; const age = /*[[${user.age}]]*/ 20; console.log(user); console.log(age)&lt;/script&gt; 在script标签中通过th:inline=&quot;javascript&quot;来声明这是要特殊处理的js脚本 语法结构： 1const user = /*[[Thymeleaf表达式]]*/ \"静态环境下的默认值\"; 因为Thymeleaf被注释起来，因此即便是静态环境下， js代码也不会报错，而是采用表达式后面跟着的默认值。 页面静态化概念静态化是指把动态生成的HTML页面变为静态内容保存，以后用户的请求到来，直接访问静态页面，不再经过服务的渲染。 目前，静态化页面都是通过模板引擎来生成，而后保存到nginx服务器来部署。 常用的模板引擎比如： Freemarker Velocity Thymeleaf 使用Thymeleaf实现概念： Context：thymeleaf运行上下文， 存放数据模型 当与SpringBoot结合使用时，我们放入Model的数据就会被处理到Context，作为模板渲染的数据使用。 TemplateResolver：模板解析器，用来读取模板相关的配置 当与SpringBoot结合时，TemplateResolver已经由其创建完成，并且各种配置也都有默认值。 TemplateEngine：模板引擎， 用来解析模板的引擎 SpringBoot中已经自动配置了模板引擎 静态化方法：templateEngine.process(&quot;模板名&quot;, context, writer); 代码实现： service 12345678910111213141516public void createGoodsHtml(Long spuId, Map&lt;String, Object&gt; attributeMap) { // 创建thymeleaf运行上下文 Context context = new Context(); // 设置参数 context.setVariables(attributeMap); String filename = \"C:\\\\ProgramFiles\\\\nginx-1.17.8\\\\html\\\\goods\\\\\" + spuId + \".html\"; try( FileWriter writer = new FileWriter(filename) ) { // 生成html文件 templateEngine.process(\"goods\", context, writer); } catch (Exception e) { log.error(\"[商品详情页{}.html静态化失败]: \", spuId, e); }} controller 12345678910@GetMapping(\"/{id}.html\")public String toGoodsPage(@PathVariable(value = \"id\") Long spuId, Model model) { Map&lt;String, Object&gt; attributeMap = goodsService.queryGoodsbySpuId(spuId); model.addAllAttributes(attributeMap); // 生成静态页面 goodsService.createGoodsHtml(spuId, attributeMap); // 返回页面视图 return \"goods\";} 配置nginx 1234567891011121314151617 server { listen 80; server_name www.leyou.com;# location映射规则, proxy_pass代理转发 location /goods { # 先找本地 root html; # 请求的文件不存在，就反向代理 if (!-f $request_filename) { proxy_pass http://127.0.0.1:8084; break; } proxy_connect_timeout 600; proxy_read_timeout 600; } }","link":"/2020/05/06/Spring/thymeleaf/"},{"title":"SpringBoot项目中使用切面记录系统日志","text":"在SpringBoot项目中使用切面记录系统日志 导入aop依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 创建日志类1234567891011121314151617@Datapublic class SysLog { private Long id; @JsonFormat(pattern = \"yyy-MM-dd HH:mm:ss\") private Date visitTime; private String ip; private String uri; private String username; /** 访问的方法 */ private String method; /** 执行时间*/ private Long execTime;} 先创建查看日志的接口 controller 12345678910111213141516@RestController@RequestMapping(\"/syslog\")public class SysLogController { @Autowired private SysLogService sysLogService; @GetMapping public ResponseEntity&lt;List&lt;SysLog&gt;&gt; querySysLog() { List&lt;SysLog&gt; sysLogs = sysLogService.querySysLog(); if (CollectionUtils.isEmpty(sysLogs)) { return ResponseEntity.status(HttpStatus.NOT_FOUND).build(); } return ResponseEntity.ok(sysLogs); }} service 1234567891011121314151617181920212223242526272829303132333435363738@Servicepublic class SysLogService { @Autowired private StringRedisTemplate redisTemplate; private ObjectMapper objectMapper = new ObjectMapper(); /** redis key */ private final String KEY = \"syslog\"; public List&lt;SysLog&gt; querySysLog() { BoundListOperations&lt;String, String&gt; ops = redisTemplate.boundListOps(KEY); return ops.range(0, -1).stream() .map(s -&gt; { try { return objectMapper.readValue(s, SysLog.class); } catch (JsonProcessingException e) { e.printStackTrace(); return null; } }).collect(Collectors.toList()); } public void save(SysLog sysLog) { if (sysLog == null) { return; } BoundListOperations&lt;String, String&gt; ops = redisTemplate.boundListOps(KEY); try { ops.rightPush(objectMapper.writeValueAsString(sysLog)); } catch (JsonProcessingException e) { e.printStackTrace(); } }} 创建AOP切面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Component@Aspect@Slf4jpublic class SysLogAop { /** 访问的类 */ private Class clazz; /** 访问的方法 */ private String methodName; /** 访问时间 */ private Date visitTime; @Autowired private HttpServletRequest request; @Autowired private SysLogService sysLogService; /** 切点 */ @Pointcut(\"execution(* com.tan.controller.*.*(..))\") public void controllerPointcut() { } /** 前置通知 */ @Before(\"controllerPointcut()\") public void before(JoinPoint joinPoint) { visitTime = new Date(); // 获取访问的类、方法 clazz = joinPoint.getTarget().getClass(); methodName = joinPoint.getSignature().getName(); } /** 后置通知 */ @After(\"controllerPointcut()\") public void after(JoinPoint joinPoint) { // 不记录查看日志操作 if (clazz == SysLogController.class) { return; } // 获取用户 这里我是用user简单模拟一下 String username = \"user\"; // 执行时间 long execTime = System.currentTimeMillis() - visitTime.getTime(); // ip String ip = request.getRemoteAddr(); // uri String uri = request.getRequestURI(); // 封装数据 SysLog sysLog = new SysLog(); sysLog.setVisitTime(visitTime); sysLog.setExecTime(execTime); sysLog.setMethod(methodName); sysLog.setIp(ip); sysLog.setUri(uri); sysLog.setUsername(username); // 持久化 sysLogService.save(sysLog); log.info(\"SysLog: {}\", sysLog); }} 重启服务，此后我们所访问controller都会被记录下来啦。","link":"/2020/05/03/Spring/%E8%AE%B0%E5%BD%95%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97/"},{"title":"MySQL笔记","text":"MySQL 数据库操作123456789101112131415select version(); -- 显示数据库版本select now(); -- 显示时间show databases; -- 查看所有数据库select database(); -- 查看当前使用的数据库use 数据库名; -- 使用数据库create database 数据库名 charset=utf8; -- 创建数据库show create database 数据库名; -- 查看创建数据库的语句 drop database 数据库名; -- 删除数据库 数据表操作123456789101112131415161718192021222324252627282930313233343536-- 查看当前数据库中所有表show tables;-- 查看表结构desc 表名;-- 查看表的创建语句show create table 表名;-- 创建表-- create table 数据表名字 (字段 类型 约束, ...);-- 约束：not null、 primary key、default-- auto_increment表示自动增长(插入数据时可以使用0 / default占位)create table students ( id bigint unsigned not null auto_increment primary key, name varchar(30) not null, age tinyint unsigned default 0, high decimal(5,2), -- 规定存储的值不超过5位数，且小数点后面有2位数字 gender enum(\"男\", \"女\") default \"女\");-- 插入数据insert [into] 表名 values(...)insert [into] 表名(列名,...) values(...)insert [into] 表名(列名,...) values(...), (...) ... -- 插入多列--- 修改update 表名 set 列1=值1,列2=值2... where 条件;-- 物理删除delete from 表名 where 条件-- 逻辑删除： 用一个字段来表示 这条信息是否已经不能再使用了-- 如：给表添加一个is_delete字段[bit(1)], 为true表示改行信息不在使用alter table 表名 add is_delete bit(1) default 0;update 表名 set is_delete=1 where 条件; -- 修改标记 查询相关查询123456789101112131415161718192021222324select 字段[as 别名] , 字段[as 别名] from 数据表 where ....;-- like模糊查询: 效率低。 %替换任意个字符， _替换一个字符select name from students where name like \"小%\";-- rlike 查询中使用正则select name from students where name rlike \"^小.*\"; -- 范围查询-- in (), not in(), between ... and ..., not between ... and ...select name from students where age in (1, 2, 3);select * from students where age between 18 and 34;-- 空判断: is null, is not nullselect * from students where high is null;-- 排序-- order by 字段1 [asc(默认升序) / desc(降)], 字段2 [] ...select * from students order by age asc, height desc;-- 聚合函数-- count(*)总数， max()最大值， min(), sum(), avg(), round(数, 精度)四舍五入-- 男性的平均身高 保留2位小数select round(avg(height), 2) from students where gender=2; 分组group by12345678910111213141516171819202122232425-- 在students表中，按照性别分组,查询所有的性别-- 失败select * from students group by gender;select gender from students group by gender;-- 在students表中，计算每种性别中的人数select gender,count(*) from students group by gender;-- 在students表中，计算男性的人数select count(*) from students where gender=1;select gender,count(*) from students where gender=1 group by gender;-- group_concat(...)-- 在students表中，查询男性中的姓名select gender, group_concat(name) from students where gender=1 group by gender;| gender | group_concat(name) |+--------+--------------------+| 男 | tt1,tt2 |+--------+--------------------+-- having-- 在students表中，按照性别分组，查询平均年龄超过30岁的性别，以及姓名 having avg(age) &gt; 30select gender, group_concat(name), avg(age) from students group by gender having avg(age)&gt;30;-- 在students表中，查询每种性别中的人数多于2个的信息select gender, group_concat(name), count(*) from students group by gender having count(*)&gt;2; 分页limit123456789101112131415-- limit offset, size 从哪儿开始 每页显示个数 使用在where、order、having后-- 在students表中，查询前5个数据 offset=0省略select * from students limit 5;-- limit (第N页-1)*每页的个数, 每页的个数-- 在students表中，每页显示2个，第1个页面select * from students limit 0, 2;-- 在students表中，每页显示2个，第2个页面select * from students limit 2, 2;-- 在students表中，每页显示2个，第3个页面select * from students limit 4, 2;-- 在students表中，查询女性信息 并且按照身高从高到矮排序 只显示前2个select * from students where gender=2 order by height desc limit 0,2; 连接查询 left join （左连接）：返回左表中的所有记录和右表中连接字段相等的记录，不相等的记录的所有字段用null填充。 right join （右连接）：返回右表。。。 inner join （等值连接/内连接）：只返回两个表中连接字段相等的行。 full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录。 1234567891011121314-- 查询 有能够对应班级的学生以及班级信息select * from students inner join classes on students.cls_id=classes.id;-- 查询 有能够对应班级的学生以及班级信息，显示学生的所有信息，只显示班级名称select s.*, c.name from students as s inner join classes as c on s.cls_id=c.id;-- 查询 有能够对应班级的学生以及班级信息, 并排序（先按班级进行排序，班级内按学生id排序）。select c.name , s.* from students as s inner join classes as c on s.cls_id=c.id order by c.name, s.id;select * from students as s left join classes as c on s.cls_id=c.id;-- 查询没有对应班级信息的学生-- select ... from xxx as s left join xxx as c on..... where/having .....select * from students as s left join classes as c on s.cls_id=c.id where c.id is null; 子查询12345678-- 查询出高于平均身高的信息select * from students where height &gt; (select avg(height) from students);-- 查询最高的男生信息select * from students where height = (select max(height) from students);-- 查询学生的班级号能够对应的学生信息select * from students where cls_id in (select id from classes); 自关联实现省级联动效果: http://demo.lanrenzhijia.com/2014/city0605/ 12345678910111213141516171819-- 创建areas表create table areas( aid int primary key, atitle varchar(20), pid int);-- 导入数据source areas.sql-- 查询所有省份select * from areas where pid is null; -- 查询出山东省有哪些市select * from areas as province inner join areas as city on city.pid=province.aid having province.atitle=\"山东省\";select province.atitle, city.atitle from areas as province inner join areas as city on city.pid=province.aid having province.atitle=\"山东省\";-- 查询出青岛市有哪些县城select province.atitle, city.atitle from areas as province inner join areas as city on city.pid=province.aid having province.atitle=\"青岛市\";select * from areas where pid=(select aid from areas where atitle=\"青岛市\") exists / not existsexists / not exists子句根据其内查询语句的结果集空或者非空，返回一个布尔值。结果集不为空exists返回true， 为空exists放回false， not exists则相反。 例子 123select * from table where exists(select false); -- exists返回true，有结果select * from table where exists(select null); -- exists返回true，有结果select * from table where exists(select 0); -- exists返回true，有结果 exists / in 查询 12select * from a where exists(select * from b where b.a_id = a.id);select * from a where id in (select a_id from b); in与exists 执行过程不同。in先执行子表，exists先执行外表。 exists强调的是是否返回结果集，不要求知道返回什么。 使用场景: 如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用in。 如果外层的主查询记录较少，子查询中的表大，又有索引时使用exists。 case when函数用于分类统计 1234567891011121314151617181920212223242526-- 薪资分类select name, sal,(case when sal &lt;= 1000 then 'C'when sal &gt; 1000 and sal &lt;= 2000 then 'B'else 'A' end) sal_classfrom sal;/*t1 1000.21 Bt2 2000.21 At3 3000.21 At4 5000.21 At5 100.21 C*/-- 按薪资分类统计平均薪资select (case when sal &lt;= 1000 then 'C'when sal &gt; 1000 and sal &lt;= 2000 then 'B'else 'A' end) sal_class ,avg(sal) from salgroup by sal_class;/*B 1000.21A 3333.543333C 100.21*/ 空值处理ifnull(col, value)函数 1select * from emp order by ifnull(comm, -1); 事务12345-- 关闭自动提交set autocommit = 0;.......-- 手动提交commit; 安装mariadb安装在centos系统中安装 刚安装完mariadb后使用mysql_secure_installation脚本，在第一步输入密码可能会失败，可以重启系统再次进行配置 12345yum install mariadb mariadb-serversystemctl start mariadb #启动mariadbsystemctl enable mariadb #设置开机自启动mysql_secure_installation #设置root密码、远程访问等信息mysql -uroot -p #登录(默认密码为空) 乱码解决设置字符集，设置好后，在连接数据库时候，指定编码，比如使用jdbc连接时，指定连接为utf8方式. 123456789101112131415161718192021222324-- 远程/代码控制数据乱码SHOW VARIABLES LIKE 'character%'; -- 查看系统默认字符集SHOW VARIABLES LIKE 'collation_%'; -- 修改编码: 使用mysql命令SET NAMES 'utf8'; -- 修改client、connection、results 三个字符集SET character_set_database = utf8 ;SET character_set_server = utf8 ;-- 修改编码：该配置文件vim /etc/my.cnf # 在[mysqld]标签下添加下面内容default-storage-engine = innodbinnodb_file_per_tablemax_connections = 4096collation-server = utf8_general_cicharacter-set-server = utf8vim /etc/my.cnf.d/client.cnf# 在[client]标签下添加下面内容default-character-set=utf8vim /etc/my.cnf.d/mysql-clients.cnf# 在[mysql]标签下添加下面内容default-character-set=utf8 DCL管理用户1234567891011-- 添加用户CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';-- 删除用户DROP USER '用户名'@'主机名'; -- 更改密码 UPDATE USER SET PASSWORD = PASSWORD('新密码') WHERE USER = '用户名';SET PASSWORD FOR '用户名'@'主机名' = PASSWORD('新密码');-- 查询用户；mysql.user表中USE myql;SELECT user, password, host FROM USER; 权限管理123456789101112131415161718-- 查询权限SHOW GRANTS FOR '用户名'@'主机名';SHOW GRANTS FOR 'lisi'@'%';-- 授予权限：grant 权限列表 on 数据库名.表名 to '用户名'@'主机名';-- 给张三用户授予所有权限，在任意数据库任意表上GRANT ALL ON *.* TO 'zhangsan'@'localhost';-- 撤销权限：revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名';-- 例子: 创建tt用户，并授予最高权限create user 'tcb'@'%' identified by 'Tan12345';grant all privileges on *.* to 'tcb'@'%';-- 赋予用户在指定主机上连接数据库，并赋予相应权限。-- mysql.user表中记录着权限分配（用户，对应客户端主机）grant 权限列表 privileges on *.* to [username]@\"[host]\" identified by \"[password]\"; 例：开放其他主机远程连接数据库权限 123456-- 允许用户root使用密码root在任何主机上连接该数据库，并赋予该用户所有权限。-- 1. 服务器开3306端口 firewall-cmd --add-port=3306/tcp --permanentfirewall-cmd --reload-- 2. 进入数据库授予用户权限grant all privileges on *.* to root@\"%\" identified by \"root\" -- %通配符代表任意主机","link":"/2020/05/01/database/MySQL/"},{"title":"es 数据备份、还原、迁移","text":"es 数据备份、还原、迁移 snapshot API文档：https://www.elastic.co/guide/cn/elasticsearch/guide/current/backing-up-your-cluster.html Reindex API将文档从源复制到目标。 文档：https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html#docs-reindex 示例将53服务器上的doc索引 topicid属性不为空的文档，复制到 52服务器（本机）上 配置允许reindex的远程主机 在elasticsearch.yml文件中增加配置: reindex.remote.whitelist: [10.0.0.53:9200] 调用52服务器的reindex API 12345678910111213141516171819202122POST _reindex{ \"source\": { \"remote\": { \"host\": \"http://10.0.0.53:9200\" }, \"size\": 1000, \"index\": \"doc\", \"query\": { \"bool\": {\"must_not\": [ {\"term\": { \"topicid\": { \"value\": \"\" } }} ]} } }, \"dest\": { \"index\": \"doc\" }} 调用时遇到问题： 12345678{ \"type\": \"illegal_argument_exception\", \"reason\": \"Remote responded with a chunk that was too large. Use a smaller batch size.\", \"caused_by\": { \"type\": \"content_too_long_exception\", \"reason\": \"entity content is too long [402906671] for the configured buffer limit [104857600]\" }} 搜索发现这个缓冲区好像被写死了，没有办法调大。最后我将size改变为50，完成复制工作。 elasticsearch-dump项目：https://github.com/elasticsearch-dump/elasticsearch-dump 常用参数: –input: 源 –output: 目标 –type: 类型 –limit: 批量操作，每次处理的数据 –fileSize: 按文件大小分片 备份脚本1234567891011121314151617181920#!/bin/shif [ $# -eq 0 ]; then echo \"请指定索引！\" echo \"sh $0 index\" exit -1fiip=192.168.1.206port=9202backup_dir=./backupindex=$1dir=${backup_dir}/${index}url=http://${ip}:${port}/${index}mkdir -p ${backup_dir}/$index./bin/elasticdump --input=$url --output=${dir}/analyzer.json --type=analyzer./bin/elasticdump --input=$url --output=${dir}/mapping.json --type=mapping./bin/elasticdump --input=$url --output=${dir}/index.json --type=data --fileSize=1gb 恢复脚本","link":"/2021/06/10/database/es-dump/"},{"title":"使用 Elasticsearch 遇到的一些问题","text":"使用 Elasticsearch 遇到的一些问题 黄色分片问题集群变为黄色，显示 “无法获取内存中分片锁” 错误消息。 原文：https://aws.amazon.com/cn/premiumsupport/knowledge-center/es-in-memory-shard-lock/ 要解决错误消息，请尝试以下方法： 排查您的黄色群集状态。 增加最大重试设置。 更新副本数量(负载高时，不建议使用)。 操作： 123456789101112131415161718192021222324252627// 查看哪些索引导致集群进入黄色状态GET /_cat/indices?v&amp;health=yellow// 查询来识别集群未分配分片的根本原因GET /_cluster/allocation/explain// 增加最大重试设置 （默认5）PUT /info/_settings{\"index.allocation.max_retries\" : 10}// 要更改副本数量// 1. 删除所有副本，使受影响的索引数量变为 0：PUT /info/_settings{ \"index\" : { \"number_of_replicas\" : 0 }}// 2. 将副本数量更改回所需的数量PUT /info/_settings{ \"index\" : { \"number_of_replicas\" : 1 }} 进行上述操作后，问题并没有得到解决。后来系统占用小了（主要是内存降下来），就没有发现没有黄色分片了。 磁盘使用率过高，无法创建副本 文档：https://www.elastic.co/guide/en/elasticsearch/reference/5.2/disk-allocator.html#disk-allocator 我 es 集群中有一台电脑磁盘占用90%（3T），该节点上的所有分片都变成了灰色，使用以下方案解决了该问题。 临时修改12345678PUT _cluster/settings{ \"transient\": { \"cluster.routing.allocation.disk.watermark.low\": \"150gb\", \"cluster.routing.allocation.disk.watermark.high\": \"100gb\", \"cluster.info.update.interval\": \"1m\" }} 永久有效修改 es 配置文件 elasticsearch.yml 123cluster.routing.allocation.disk.threshold_enabled: truecluster.routing.allocation.disk.watermark.low: 150gbcluster.routing.allocation.disk.watermark.high: 100gb","link":"/2021/04/02/database/es-issues/"},{"title":"es 中使用 painless 脚本","text":"es 中使用 painless 脚本 Painless 语法与 Java 类似 相关文章： https://yuerblog.cc/2018/08/23/painless-doc-values/ 访问field文档的field数据存储在doc、ctx._source 中， 是map类型的。 非text、非nested 的field 存到 doc values 列存储中, IO性能好 假设你有一个字段：”a”: 1。 那么doc[‘a’]返回的是[1]，是一个数组。 doc[‘a’].value返回的是1，也就是取第一个元素。 doc[‘a’].values与doc[‘a’]表现一致，返回[1]。 特殊一点的是object类型的字段，ES底层存储时是key扁平化的，所以你应该直接这样取： doc[‘xxx.yyy’] doc[‘xxx.yyy’].value doc[‘xxx.yyy’].values 在查询中使用123456789101112// 查 flag = '00000' 的GET _search{ query: { script: { script: { inline: \"doc['flag'].value == '00000'\", lang: \"painless\", }, }, }, }; 更新时使用12345678910111213141516POST /_update_by_query{ &quot;script&quot;: { &quot;inline&quot;: &quot;ctx._source.flag = params.flag&quot;, &quot;params&quot;: { flag: '11111' } }, &quot;query&quot;: { &quot;script&quot;: { &quot;script&quot;: { &quot;inline&quot;: &quot;doc.flag[0].startsWith('0')&quot; } } }} 删除时使用12345678910POST /_delete_by_query{ \"query\": { \"script\": { \"script\": { \"inline\": \"doc.flag[0].startsWith('0')\" } } }}","link":"/2021/03/29/database/es-plainless/"},{"title":"Elasticsearch","text":"官网：https://www.elastic.co/cn/ ELK技术栈：Elasticsearch、Kibana、Logstash等 ElasticsearchElasticsearchElasticsearch是基于Lucene的全文检索技术，基于倒排索引，采用Rest风格API。 默认端口：9200用于http连接; 9300用于tcp连接 注意：安装需要保证elasticsearch、kibana、analysis_ik版本一致。 elasticsearch-heades的管理界面，安装相关chrome拓展使用 项目地址：https://github.com/mobz/elasticsearch-head KibanaKibana是一个基于Node.js的Elasticsearch索引库数据统计工具，可以利用Elasticsearch的聚合功能，生成各种图表，如柱形图，线状图，饼图等。默认端口5601。 IK Analysis项目地址： https://github.com/medcl/elasticsearch-analysis-ik Analyzer: ik_smart , ik_max_word 测试安装结果： 打开kibana控制台，输入如下请求，若成功分词则成功安装 12345POST _analyze{ \"analyzer\": \"ik_smart\", \"text\": \"我是中国人\"} 操作索引indices相关概念 索引库（indices) 类型（type）： 7.x已经移出这个概念，使用_doc兼容 映射配置（mappings）：字段的数据类型、属性、是否索引、是否存储等特性 文档（document） 字段（field） 一些集群相关的概念: 集群（cluster） 节点(node) 索引集（Indices，index的复数）：逻辑上的完整索引 分片（shard）：数据拆分后的各个部分 副本（replica）：每个分片的复制 创建索引1234567891011PUT index{ \"settings\": { # 分片数，副本数 \"number_of_shards\": 3, \"number_of_replicas\": 2 }, # 映射配置 \"mappings\": { }} 查看索引12GET indexGET * 删除索引1DELETE index 映射配置elasticsearch7.x中移除了类型(Type)这个概念，要使用_doc占位。 创建映射字段 1234567891011PUT /索引库名/_mapping/类型名称{ \"properties\": { \"字段名\": { \"type\": \"类型\", # 可以是text、long、short、date、integer、object等 \"index\": true， # 是否索引 \"store\": true， # 是否存储 \"analyzer\": \"分词器\" } }} 12345678910111213141516PUT index/_mapping/_doc{ \"properties\": { \"title\": { \"type\": \"text\", \"analyzer\": \"ik_max_word\" }, \"images\": { \"type\": \"keyword\", \"index\": \"false\" }, \"price\": { \"type\": \"float\" } }} 查看映射关系 1GET /索引库名/_mapping 字段属性 type: 字段类型 String类型，又分两种： text：可分词，不可参与聚合 keyword：不可分词，数据会作为完整字段进行匹配，可以参与聚合 Numerical：数值类型，分两类 基本数据类型：long、interger、short、byte、double、float、half_float 浮点数的高精度类型：scaled_float 需要指定一个精度因子，比如10或100。elasticsearch会把真实值乘以这个因子后存储，取出时再还原。 Date：日期类型 elasticsearch可以对日期格式化为字符串存储，但是建议我们存储为毫秒值，存储为long，节省空间。 index: 是否索引 不索引，则不能用于搜索 默认为true， 索引 store：是否将数据进行额外存储 默认为false，不进行额外存储 es在创建索引时，会将文档所有数据保存到_source。因此，不论store为何值都可以搜到结果。 boost：激励因子 操作文档document新增文档 单个 12345POST/PUT /index/_doc/id可写可不写{ \"title\":\"小米手机\" \"price\":2699.00} 批量新增 12345POST /index/_doc/_bulk{ \"index\":{} }{ \"title\":\"OnePlus8\",\"price\":3999 }{ \"index\":{} }{ \"title\":\"OnePlus8 pro\",\"price\":4999 } 修改文档 根据id 12345PUT /index/_doc/3{ \"title\":\"超大米手机\" \"price\":3899.00} 批量修改 12345678910POST goods/_update_by_query{ \"script\": { \"inline\": \"ctx._source.price = params.price\", \"params\": { \"state\": 9999 } }, \"query\": {\"match_all\": {}}} 删除文档 根据id删 1DELETE /索引库名/类型名/id值 批量删除 1234POST goods/_delete_by_query{ \"query\": {\"match_all\": {}}} 查看文档 根据id查询 1GET /index/_doc/3 查询基本语法1234567891011121314151617181920212223GET /索引库名/_search{ # 查询 \"query\":{ \"查询类型\":{ \"查询条件\":\"查询条件值\" } } # 设置要显示的字段 \"_source\": [\"field\", ...], # 排序 \"sort\": [{\"field\": {\"order\": \"desc|asc\"}}, ...], # 分页 \"from\": 从第几个开始 \"size\": 每页显示几个}// orGET index/type/_idGET index/_search?field=value 查询query 查询类型：match_all， match，term ， range 等等 查询条件：文档field _source设置要显示的field 直接指定要显示的字段&quot;_source&quot;: [&quot;field&quot;, ...], 使用includes和excludes 1234\"_source\": { \"includes\": \"{field}\", # 需要的字段 \"excludes\": \"{field}\" # 不需要的字段}, sort排序 1234\"sort\": [ {\"price\": {\"order\": \"desc\"}}, {\"_score\": {\"order\": \"desc\"}}] match_all查询所有 示例 123456GET index/_search{ \"query\":{ \"match_all\": {} }} 返回结果 123456789101112131415161718192021222324252627282930{ \"took\" : 1, # 查询花费的时间, 单位ms \"timed_out\" : false, # 是否超时 \"_shards\" : { # 分片信息 \"total\" : 1, \"successful\" : 1, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { # 搜索结果总览对象 \"total\" : { # 命中纪录数 \"value\" : 4, \"relation\" : \"eq\" }, \"max_score\" : 1.0, # 所有结果中最高文档得分 \"hits\" : [ { \"_index\" : \"index\", \"_type\" : \"_doc\", \"_id\" : \"1\", \"_score\" : 1.0, # 文档得分 \"_source\" : { # 源数据 \"title\" : \"超大米手机\" \"price\" : 3899.0 } }, ... ] }} match查询match类型查询，会把查询条件进行分词，然后进行查询，默认是or关系 or关系 12345678GET index/_search{ \"query\": { \"match\": { \"title\": \"小米手机\" } }} and关系 1234567891011GET index/_search{ \"query\": { \"match\": { \"title\": { \"query\": \"小米手机\", \"operator\": \"and\" } } }} multi_match查询与match查询类似，不同在于它可以在多个字段中查询 12345678910# 在title和subTitle两个filed中查找GET index/_search{ \"query\": { \"multi_match\": { \"query\": \"小米手机\", \"fields\": [\"title\", \"subTitle\"] } }} term词条匹配term 查询被用于精确值 匹配，这些精确值可能是数字、时间、布尔或者那些未分词的字符串 12345678GET index/_search{ \"query\": { \"term\": { \"price\": 3899.0 } }} terms多词条精确匹配terms 查询和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件 12345678GET index/_search{ \"query\": { \"terms\": { \"price\": [2699.0, 3899.0] } }} querystring查询123456789GET index/_search{ \"query\": { \"query_string\": { \"default_field\": \"title\", \"query\": \"小米手机\" } }} range范围查询range 查询找出那些落在指定区间内的数字或者时间 操作符 gt、gte、lt、lte(大于、大于等于、小于、小于等于) 1234567891011GET index/_search{ \"query\": { \"range\": { \"price\": { \"gte\": 2000, \"lte\": 3000 } } }} fuzzy模糊查询fuzzy 查询是 term 查询的模糊等价。它允许搜索词条与实际词条的拼写出现偏差，但偏差的编辑距离不得超过2 123456789GET index/_search{ \"query\": { \"fuzzy\": { \"title\": \"appla\" } }}# 能成功检索到apple bool布尔组合查询bool把各种其它查询通过must（与）、must_not（非）、should（或）的方式进行组合 123456789101112131415161718192021GET index/_search{ \"query\": { \"bool\": { \"must\": [ { \"range\": { \"price\": { \"gt\": 3000 } } }, { \"match\": { \"title\": \"小米\" } } ] } }} filter过滤filter在bool中使用，在filter中还可以再次使用bool查询。 如果我们需要在查询结果中进行过滤，并且不希望过滤条件影响评分，那么就不要把过滤条件作为查询条件来用。而是使用filter方式。（所有的查询都会影响到文档的评分及排名。） 123456789101112131415161718192021GET index/_search{ \"query\": { \"bool\": { \"must\": [ {\"match\": { \"title\": \"小米手机\" } } ], \"filter\": { \"range\": { \"price\": { \"gte\": 2000, \"lte\": 3000 } } } } }} 滚动查询文档：https://www.elastic.co/guide/cn/elasticsearch/guide/current/scroll.html 使用原因： es 默认翻页查询最多能查前10000 条数据（可修改） 数据量大，性能更好 12345678910111213// scroll 游标有效时间GET /index/_search?scroll=1m { \"query\": { \"match_all\": {}}, \"size\": 100}// scroll_id 上面查询返回的 _scroll_idGET /_search/scroll{ \"scroll\": \"1m\", \"scroll_id\" : \"\"} es null valuees 将不存在的值视为空值( 如：null , “” , [], {} ) 123456789101112GET /index/_search{ \"query\": { \"bool\": { \"must_not\": [ { \"exists\": { \"field\": \"title\"} } ] } }} 聚合aggregations基本概念bucket桶： 桶的作用，是按照某种方式对数据进行分组，每一组数据在ES中称为一个桶，类似sql的分组。 Elasticsearch中提供的划分桶的方式有很多： Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组 Histogram Aggregation：根据数值阶梯(interval)分组，与日期类似 Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组 Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组 …… 分桶语法： 123456789GET cars/_search{ \"size\": 0, # 不显示查询内容，只显示聚合结果 \"aggs\": { # 聚合 \"NAME\": { # 聚合名 \"AGG_TYPE\": {} # 分桶方式 } }} metrics度量： 分组完成以后，我们一般会对组中的数据进行聚合运算，例如求平均值、最大、最小、求和等，这些在ES中称为度量 比较常用的一些度量聚合方式： Avg Aggregation：求平均值 Max Aggregation：求最大值 Min Aggregation：求最小值 Percentiles Aggregation：求百分比 Stats Aggregation：同时返回avg、max、min、sum、count等 Sum Aggregation：求和 Top hits Aggregation：求前几 Value Count Aggregation：求总数 …… 聚合为桶 准备数据 12345678910111213141516171819PUT /cars{ \"settings\": { \"number_of_shards\": 1, \"number_of_replicas\": 0 }, \"mappings\": { \"transactions\": { \"properties\": { \"color\": { \"type\": \"keyword\" }, \"make\": { \"type\": \"keyword\" } } } }} 1234567891011121314151617POST /cars/transactions/_bulk{ \"index\": {}}{ \"price\" : 10000, \"color\" : \"red\", \"make\" : \"honda\", \"sold\" : \"2014-10-28\" }{ \"index\": {}}{ \"price\" : 20000, \"color\" : \"red\", \"make\" : \"honda\", \"sold\" : \"2014-11-05\" }{ \"index\": {}}{ \"price\" : 30000, \"color\" : \"green\", \"make\" : \"ford\", \"sold\" : \"2014-05-18\" }{ \"index\": {}}{ \"price\" : 15000, \"color\" : \"blue\", \"make\" : \"toyota\", \"sold\" : \"2014-07-02\" }{ \"index\": {}}{ \"price\" : 12000, \"color\" : \"green\", \"make\" : \"toyota\", \"sold\" : \"2014-08-19\" }{ \"index\": {}}{ \"price\" : 20000, \"color\" : \"red\", \"make\" : \"honda\", \"sold\" : \"2014-11-05\" }{ \"index\": {}}{ \"price\" : 80000, \"color\" : \"red\", \"make\" : \"bmw\", \"sold\" : \"2014-01-01\" }{ \"index\": {}}{ \"price\" : 25000, \"color\" : \"blue\", \"make\" : \"ford\", \"sold\" : \"2014-02-12\" } 聚合 123456789101112131415GET cars/_search{ \"size\": 0, \"aggs\": { \"popular_colors\": { \"terms\": { \"field\": \"color\", \"size\": 10, # 显示的桶数 \"order\": { \"_key\": \"asc\" # 根据聚合的field排序 } } } }} 桶内度量聚合后会默认指挥返回每个桶里面的文档数量，通常我们需要跟复杂的文档度量。 这时我们就需要度量，在aggs中添加新的aggs，即桶内的聚合，可见度量也是一个聚合 求每个桶价格的平均值 12345678910111213141516171819GET cars/_search{ \"size\": 0, \"aggs\": { \"popular_colors\": { \"terms\": { \"field\": \"color\", \"size\": 10 }, \"aggs\": { \"avg_price\": { \"avg\": { \"field\": \"price\" } } } } }} 返回结果 123456789101112131415161718192021222324252627282930... \"aggregations\" : { \"popular_colors\" : { \"doc_count_error_upper_bound\" : 0, \"sum_other_doc_count\" : 0, \"buckets\" : [ { \"key\" : \"red\", \"doc_count\" : 4, \"avg_price\" : { \"value\" : 32500.0 } }, { \"key\" : \"blue\", \"doc_count\" : 2, \"avg_price\" : { \"value\" : 20000.0 } }, { \"key\" : \"green\", \"doc_count\" : 2, \"avg_price\" : { \"value\" : 21000.0 } } ] } }","link":"/2021/03/29/database/es/"},{"title":"MongoDB","text":"MongoDB是一个基于分布式文件存储的面向文档的数据库，多用于数据采集和分散处理(Map/Reduce)，特别是在大数据处理方面比较擅长。 MongoDB 是介于关系/非关系数据库之间的产品，是非关系数据库中最像关系数据库的。查询功能强大，类似关系数据库。 数据库排行：https://db-engines.com/en/ranking 官网：https://www.mongodb.com/ 教程：https://github.com/komavideo/LearnMongoDB 数据/集合操作123456789101112131415show dbs// 进到test数据库use test// 删除当前数据库db.dropDatabase()show collectionsshow tables// 创建集合 db.createCollection(\"posts\")// 重命名db.posts.renameCollection(\"temp\")// 删除集合db.temp.drop() 文档操作123456789101112131415161718192021222324252627282930db.posts.insert({title: 'blog1', author: 'tt'})db.posts.remove({})// 查db.posts.findOne()db.posts.find({}, {field1: true, field2: 1})// 参数1：指定过滤条件，参数2：指定显示的属性// $gte, $gt, $lte, $lt, $eq, $ne, 支持正则db.posts.find({$or:[{...},{...}]})db.posts.find({\"\": {$in: [...]}})// 存在某个属性的db.posts.find({\"\": {$exists: true}})// 排序 1升序，-1降序sort({field: 1})// 共多少个db.posts.count()// 跳过多少个（offset）skip()// 显示多少个limit()// 更新update(&lt;filter&gt;, &lt;update&gt;, &lt;options&gt;)// &lt;update&gt; $inc:递加， $mul:相乘， $rename:改名， $set:新增or修改、$unset:字段删除 // &lt;options&gt; {multi: true} 更新多条（默认只更新一条）， {upsert: true} 有则更新，无则新增db.posts.update({\"author\":\"tt\"}, {$set: {\"author\": \"tc\"}}, {multi: true})// 更新数组中的元素的字段，使用$占位。col：{arr: [{field: 'old'}]}db.col.update({'arr.field': 'old'}, {$set: {'arr.$.field': 'new'}}) 聚合https://www.runoob.com/mongodb/mongodb-aggregate.html 管道操作符: $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 $match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。 $limit：用来限制MongoDB聚合管道返回的文档数。 $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。 $group：将集合中的文档分组，可用于统计结果。 $sort：将输入文档排序后输出。 $geoNear：输出接近某一地理位置的有序文档。 栗子：统计id出现的次数 1234db.user.aggregate([ { $group : {_id : \"$id\", count : {$sum : 1}} }, { $sort: {count: -1} }]) 索引12345678getIndexes()createIndex({...}, {...})dropIndex({...})// 逆序db.posts.createIndex({rank:-1})// 唯一db.posts.createIndex({title:1}, {unique:true}) 备份还原123456789101112131415# 备份 在./dump/ 目录下mongodump -d [dbname]# 还原 --drop 先删除当前数据，然后恢复备份的数据mongorestore --drop# 指定主机、库mongodump -h 127.0.0.1:27017 -d 库名 -o 路径mongorestore -h 127.0.0.1:27017 -d 库名 路径 --dropmongoimport --db 'xz_sys' --collection 'website_channls' --file channls.json mongoexport --db 'xz_sys' --collection 'website_channls' --out channls.json db.getCollection('tables') .find({_id: 'q3hrnnoKu2mnCL7kE'}) .forEach(function(x){printjsononeline(x)});","link":"/2021/03/01/database/mongo/"},{"title":"neo4j 图数据库","text":"图数据库、语法大小写皆可 参考 https://www.cnblogs.com/ljhdo/p/5516793.html http://arganzheng.life/neo4j-multiple-labels-index.html 创建节点1234# 节点表示: (name:label1:label2 {field: value})CREATE (Hugo:Person {name:'Hugo Weaving', born:1960})create (n:Person { name: 'Tom Hanks', born: 1956 }) return nCREATE (TheMatrix:Movie {title:'The Matrix', released:1999, tagline:'Welcome to...'}) 创建关系1234567891011121314# 关系表示： (name:label1:label2 {fied, value}), 属性可有可无# 建立关系 CREATE node1 - [relationship] - node2# 1. 匹配节点 建立关系MATCH (a:Person),(b:Movie) where a.name = 'Hugo Weaving' and b.title = 'The Matrix' create (a) - [r:ACTED_IN {roles:['Agent Smith']}] -&gt; (r)# 2. 创建节点并建立关系CREATE (Hugo:Person {})CREATE (TheMatrix:Movie {})CREATE (Hugo)-[:ACTED_IN {roles:['Agent Smith']}]-&gt;(TheMatrix)# 3. 创建节点并建立关系CREATE (Hugo:Person {})-[:ACTED_IN {roles:['Agent Smith']}]-&gt;(TheMatrix:Movie {}) 查123456# 查节点MATCH (c:equip {name: 'f35'} ) return cMATCH (c:equip) where c.name = 'f35' return c# 查关系MATCH p=()-[r:ACTED_IN]-&gt;() RETURN p LIMIT 25 删除数据123# 关系依赖于节点，删除所有节点关系会自动删除MATCH (n:Person) DETACH DELETE nMATCH (n) WHERE id(n) = 3869127 DETACH DELETE n 索引12345678910# 查看索引:schema# 创建索引# CREATE INDEX ON :&lt;label&gt;(&lt;field&gt;)CREATE INDEX ON :Person(name)# 删除索引# DROP INDEX ON :&lt;label&gt;(&lt;field&gt;)DROP INDEX ON :Person(name)","link":"/2021/03/01/database/neo4j/"},{"title":"AJAX与跨域访问","text":"ASynchronous JavaScript And XML 异步和同步：在客户端和服务器端相互通信的基础上 同步：客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 异步：客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 可以提升用户的体验 注意事项服务器响应的数据，在客户端要想当做json数据格式使用， 需要在服务端设置MIME类型 content-type=application/json;charset=utf-8 js原生方式123456789101112131415161718192021222324252627282930313233343536373839//1.创建核心对象var xmlhttp;if (window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest();}else{// code for IE6, IE5 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");}//2. 建立连接/* open方法参数： 1. 请求方式：GET、POST * get方式，请求参数在URL后边拼接。send方法为空参 * post方式，请求参数在send方法中定义 2. 请求的URL： 3. 同步或异步请求：true（异步）或 false（同步）*/xmlhttp.open(\"GET\",\"ajaxServlet?username=tom\",true);//3.发送请求xmlhttp.send(); //4.接受并处理来自服务器的响应结果//获取方式 ：xmlhttp.responseText //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。xmlhttp.onreadystatechange=function(){ //判断readyState就绪状态是否为4，判断status响应状态码是否为200 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { //获取服务器的响应结果 var responseText = xmlhttp.responseText; alert(responseText); }} JQeury方式 $.ajax() 语法：$.ajax({键值对}); 123456789101112131415//使用$.ajax()发送异步请求$.ajax({ url:\"ajaxServlet1111\" , // 请求路径 type:\"POST\" , //请求方式 //data: \"username=jack&amp;age=23\",//请求参数 data:{\"username\":\"jack\",\"age\":23}, success:function (data) { alert(data); },//响应成功后的回调函数 error:function () { alert(\"出错啦...\")},//表示如果请求响应出现错误，会执行的回调函数 dataType:\"text\"//设置接受到的响应数据的格式}); $.get()：发送get请求 语法：$.get(url, [data], [callback], [type]) url：请求路径 data：请求参数 callback：回调函数 type：响应结果的类型 $.post()：发送post请求 语法：$.post(url, [data], [callback], [type]) fetch发送异步请求常用配置选项 method(String) body(String) headers(Object) 示例 123fetch(\"http://localhost/products\", {method: \"GET\"}) .then(data =&gt; data.text()) // data.text()返回的是一个Promise对象 .then(data =&gt; console.log(data)); // 这时拿到的data才是响应数据 axios发送异步请求1234567891011121314// 请求拦截器， 在请求发出前设置一些信息axios.interceptors.request.use(config =&gt; { console.log(config); config.headers.mytoken = \"hello\";},error =&gt; console.log(error))// 响应拦截器， 在获取数据前做一些处理axios.interceptors.response.use(res =&gt; console.log(res), error =&gt; console.log(error))// 发送get请求axios.get(\"http://localhost/products\") .then(resp =&gt; console.log(resp.data)) .catch(error =&gt; console.log(error)); 同源政策如果两个页面拥有相同的协议（http/https）、域名和端口，那么这两个页面就属于统一个源。 同源政策的目的就是为了保证用户信息的安全。 同源限制 A网站在客户端设置的Cookie，B网站不能访问 向非同源的地址发送ajax请求，浏览器会拒绝接收（但能发送请求）。 Jsonpjson with padding， 不属于ajax请求，但可以模拟ajax请求，解决同源限制问题。 实现步骤 将不同源的请求地址写道script标签的src属性中，并设置请求参数callbak 服务器端响应一个函数调用的字符串，让客户端调用。 1234567891011121314151617181920212223242526272829303132&lt;body&gt; &lt;button onclick=\"findAll()\"&gt;查看所有商品&lt;/button&gt; &lt;/body&gt;&lt;script&gt; // 封装jsonp操作 function jsonp(options) { // 创建script标签 let script = document.createElement(\"script\"); // 将临时的success函数挂载到window对象上 let functionName = \"jsonp\" + new Date().getMilliseconds(); window[functionName] = options.success; // 将success函数名，通过参数传递给服务器； // 服务器收到后，返回一个调用该函数的字符串代码给客户端执行 script.src = `${options.url}?callback=${functionName}`; document.body.appendChild(script); // 向dom中添加script标签 document.body.removeChild(script); // 在dom中删除script标签 } function findAll() { jsonp({ url: \"http://localhost/product/findAll\", success: function (data) { alert(JSON.stringify(data)); } }); }&lt;/script&gt; CORS跨域资源共享优质博文： https://www.ruanyifeng.com/blog/2016/04/cors.html Cross-origin resource sharing， 允许浏览器向跨域服务器发送Ajax请求。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能 。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。 因此，实现CORS通信的关键是服务器。 简单请求 请求方法是一下三者之一：HEAD、GET、POST HTTP头不能超过一下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值 application/x-www-form-urlencoded、 multipart/form-data、 text/plain 浏览器发现是简单请求的跨域访问时会携带origin头信息，服务器端如果允许来自这个源的请求，就会响应一个Access-Control-Allow-Origin头，则本次跨域请求会成功。 特殊请求 不符合简单请求的条件，会被浏览器判定为特殊请求。 特殊请求会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 一个“预检”请求的样板： 12345678OPTIONS /cors HTTP/1.1Origin: http://manage.leyou.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.leyou.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 与简单请求相比，除了Origin以外，多了两个头： Access-Control-Request-Method：接下来会用到的请求方式，比如PUT Access-Control-Request-Headers：会额外用到的头信息 服务的收到预检请求，如果许可跨域，会发出响应： 1234567891011121314HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Max-Age: 1728000Content-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 除了Access-Control-Allow-Origin和Access-Control-Allow-Credentials以外，这里又额外多出3个头： Access-Control-Allow-Methods：允许访问的方式 Access-Control-Allow-Headers：允许携带的头 Access-Control-Max-Age：本次许可的有效时长，单位是秒，过期之前的ajax请求就无需再次预检 如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。 服务器端设置响应头 Access-Control-Allow-Origin：设置允许的来源 Access-Control-Allow-Method：设置允许的请求类型 Access-Control-Allow-Headers：设置默认不能拿到的字段（ XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段 ） 解决方案3由于同源政策时浏览器给Ajax的限制，服务器端是不存在同源政策限制的。 跨域访问携带Cookie在使用Ajax发送跨域请求时，默认情况下不会携带Cookie信息 实现 客户端将XMLHttpRequest对象的withCredentials属性设置为ture，表示跨域请求时携带Cookie 浏览器端设置Access-Control-Allow-Credentials：true， 表示允许客户端携带cookie springmvc解决跨域问题 方法1：使用CorssOrign注解 方法2：注册一个CorsFilter 1234567891011121314151617181920212223242526272829303132333435import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class GlobalCorsConfig { @Bean public CorsFilter corsFilter() { //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //1) 允许的域,不要写*，否则cookie就无法使用了 config.addAllowedOrigin(\"http://manage.leyou.com\"); //2) 是否发送Cookie信息 config.setAllowCredentials(true); //3) 允许的请求方式 config.addAllowedMethod(\"OPTIONS\"); config.addAllowedMethod(\"HEAD\"); config.addAllowedMethod(\"GET\"); config.addAllowedMethod(\"PUT\"); config.addAllowedMethod(\"POST\"); config.addAllowedMethod(\"DELETE\"); config.addAllowedMethod(\"PATCH\"); // 4）允许的头信息 config.addAllowedHeader(\"*\"); //2.添加映射路径，我们拦截一切请求 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration(\"/**\", config); //3.返回新的CorsFilter. return new CorsFilter(configSource); }}","link":"/2021/03/06/js/ajax/"},{"title":"ES6","text":"ECMAScript2015(ES6)是Javascript最标准的语法式样，是在2015年6月由Ecma国籍组织公布的最新版本，现在已经被多个领域和浏览器所广泛采纳和使用。 ES6学习https://github.com/lukehoban/es6featureshttps://babeljs.io/learn-es2015/ ES6支持程度http://node.green/http://kangax.github.io/compat-table/es6/ let命令let命令比var命令更加严谨，使用let命令定义变量可以解决var定义变量的作用域问题，以及重复定义问题 123456if (true) { var i = 1; // ES5 let j = 1; // ES6}console.log(i);console.log(j); //变量i未找到 123456789var i = 0;switch (i) { case 0: let value = \"helo\"; break; case 1: let value = \"world\"; //重复定义错误 break;} const命令用于定义常量 12345678910const data = 10;//data = 100; // errorconst list = [10,20,30];list[0] = 100; // oklist.push(2); // ok//list = [1,2,3]; // error 进制转换12345678910111213console.log(0b10); //2console.log(0o10); //8console.log(0x10); //16console.log(0b11 === 3); //trueconsole.log(0o10 === 8); //trueconsole.log(0x10 === 16);//truelet num = 10;console.log(num.toString(8)); //8进制转换console.log(num.toString(2)); //2进制转换console.log(num.toString(16));//16进制转换console.log(num.toString(5)); //5进制, 看成5进制转换 嵌入字符串定义模板 1234let name = \"Koma\";let mystr = \"你好，${name}!\"; // 嵌入变量nameconsole.log(mystr); 解析模板 12345678910$ node&gt; function tagged(formats, ...args){... console.log(formats)... console.log(args)... }undefined&gt;&gt; tagged`你好，${name}！再见。`[ '你好，', '！再见。' ][ 'Koma' ] 123456789101112131415let name = \"tt\";let addr = \"重庆\"let str = markdown`我是${name}, 我住在${addr}!`;console.log(str); // 我是**tt**, 我住在**重庆**!// 关键词加粗显示function markdown(formats, ...args) { let result = \"\"; for(let i = 0; i &lt; formats.length; ++i) { result += formats[i]; result += (args[i]) ? `**${args[i]}**` : \"\"; } return result;} Symbol原始类型Symbol内部有个唯一的id（是一个hash值），在作比较时比较的是该id值。 1234567891011let str1 = String(\"HeloWorld\");let str2 = String(\"HeloWorld\");console.log(str1 == str2); //结果：trueconsole.log(str1 === str2); //结果：true, new出来的不相等let s1 = Symbol(\"mySymbol\");let s2 = Symbol(\"mySymbol\");console.log(typeof s1); //结果：symbolconsole.log(s1.toString()); //结果：Symbol(mySymbol)console.log(s1 == s2); //结果：falseconsole.log(s1 === s2); //结果：false 使用场景 作为常量 1234567891011121314const Java = Symbol();const Ruby = Symbol();const Perl = Symbol();const Php = Symbol();const VB = Symbol();var lang = Php;if (lang === Java) { console.log('Java的未来在哪里？');}if (lang === Ruby) { console.log('再学个Ruby on Rails吧。');} 作为属性 12345678910let s1 = Symbol(\"mySymbol\");let s2 = Symbol(\"mySymbol\");var obj = {};obj[s1] = \"helo\";obj[s2] = \"world\";console.log(obj);console.log(obj[s1]);console.log(obj[s2]); 办隐藏属性 12345678910111213141516171819const MYKEY = Symbol();class User { constructor(key,name,age){ this[MYKEY] = key; this.name = name; this.age = age; } checkKEY(key){ return this[MYKEY] === key; }}let user = new User(123, 'Curry', 29);console.log(user.name, user.age, user[MYKEY]);console.log(user.checkKEY(123)); //trueconsole.log(user.checkKEY(456)); //falseconsole.log(Object.keys(user)); //[ 'name', 'age' ]console.log(JSON.stringify(user)); //{\"name\":\"Curry\",\"age\":29} 解构赋值1234567891011121314151617181920212223242526//数组赋值let [a, b, c] = [10, 20, 30];console.log(a, b, c); //10 20 30let [x, y, ...other] = [1,2,3,4,5];console.log(x, y, other); //1 2 [ 3, 4, 5 ]//对象赋值let {name, age} = { name: 'Koma', age: 20 };console.log(name, age);//函数赋值function func1() { return [10, 20];}let [num1, num2] = func1(); console.log(num1, num2);//函数参数名指定function func2({x=1, y=2}){ return x+y;}console.log(func2({})); //3console.log(func2({x:10})); //12console.log(func2({y:10})); //11console.log(func2({x:10, y:20})); //30 for….of循环123456789101112131415161718192021222324let list = [10, 20, 30];Array.prototype.Len = list.length;Array.prototype.getLen = function () {return Len};// for...of 只遍历集合中的元素（只关心值）for(let val of list) console.log(val);// for...in 遍历对象中的所有属性console.log(\"----------------------\")for(let val in list) console.log(val, list[val]);/** 运行结果 10 20 30 ---------------------- 0 10 1 20 2 30 Len 3 getLen [Function]*/ 默认/可变长形参 形参默认值 12345678910111213141516function add(a=1, b=a){ return a+b;}console.log(add());console.log(add(10));console.log(add(10, 20));//必须指定参数function required(){ throw ;}function sayBye(name=required()){ console.log(`${name} bye!`);}sayBye('Koma');//sayBye(); // Error 可变长形参 12345678function sum(...args) { let result = 0; args.forEach(e =&gt; result += e); // 箭头函数 return result;}console.log(sum(1, 2, 3));console.log(sum(1, 2, 3, 4, 5, 6)); Array扩展 includes()：是否包含某个元素， 传入元素即可。 find()：查找某个元素。箭头函数返回ture表示找到了，并返回该元素。 findIndex()：返回要查找值得索引，没有则返回-1。 forEach()：遍历每一项，不能终止 some()：箭头函数返回true，终止遍历 filter()：过滤，返回一个新数组。箭头函数返回false表示过滤 reduce(): 对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值 123456&gt; let p = [{name: \"tt\", age: 12}, {name: \"ttt\", age: 14}];undefined&gt; p.reduce((a, b) =&gt; a + b.age, 0);&gt; 26// a上一次的计算的结果， b数组中的元素， reduce的第二个参数，设置a的初始值 String拓展 startsWith()：判断字符是否以…开头 endsWith() repeat(n)：将字符串重复n次，并返回新串 padStart()：用于填充字符串，如时间格式化显示。参数1字符串长度，参数2用于填充的字符 padEnd(maxLength, fillString=’’) 定义基本对象(ES5)1234567891011121314let book = { title : \"ES6从入门到学会\", price : 25, publish : \"小马出版社\", toString(){ console.log(`&lt;&lt;${this.title}&gt;&gt; is ${this.price}元。`); }};book['lang'] = \"简体中文\"; // 添加属性book.price = 49; // 修改属性zconsole.log(book);book.toString(); 类class支持继承extends 12345678910111213141516171819202122232425class Player { // 构造方法 constructor(name, age) { this.name = name; this.age = age; } // setter、getter set sex(sex) { this._sex = sex; } get sex() { return this._sex; } // 静态方法 static info() { console.log(\"这是一个球员类，您可以用它建立自己的球员！\"); } // 实例方法 show() { console.log(`${this.name} ---- ${this.age}`); }}Player.info();let player = new Player(\"tt\", 18);console.log(player); // Player { name: 'tt', age: 18 }player._sex = \"man\";console.log(player); // Player { name: 'tt', age: 18, _sex: 'man' }console.log(player.name, player._sex, player.age); // tt man 18 迭代生成器注意：fanction后面有一个* 123456789function* countDown(number) { while(number) { yield number--; }}for(let num of countDown(5)) { console.log(num); // 从5打印到1} 迭代器 方式一 12345678910111213141516171819class PlayerList { constructor(list) { this.list = list; } [Symbol.iterator]() { let cur = 0; let _list = this.list; return { next() { // {value:元素值, done: 是否停止迭代}; return cur &lt; _list.length ? {value:_list[cur++], done:false} : {done:true} } } }}let playlist = new PlayerList([\"Curry\", \"Harden\"]);for (let player of playlist) { console.log(player);} 方式二：使用yield 1234567891011class PlayerList { constructor(list) { this.list = list; this[Symbol.iterator] = function*() { let cur = 0; while (cur &lt; list.length) { yield list[cur++]; } } }} 模块化设计服务器端模块化规范(CommonJs) 模块分为单文件模块与包 导出：module.exports = {}和exports.模块名 = {} 导入：const 接收名称 = require(&quot;...&quot;) ES6统一标准 默认导出与默认导入 默认导出：export default {}， 只能导出一次 默认导入：import 接收名称 from ‘模块标识符’ 按需导出/导入 导出：export let num = 10， 可以导出多次 导入：import { num } from '...' 练习 12345678910111213// 定义两个函数function add(...args) {}function mul(...args) {}exports.model = {add, mul}; // 导出const model = require(\"./model\").model; // 导入module.exports = {add, mul}; // 导出const model = require(\"./model\"); // 导入// ES6默认导出/导入export default {add, mul};import model from 'model';","link":"/2021/03/06/js/es6/"},{"title":"javascript","text":"ECMAScript：欧洲计算机协会 BOM(broswer object model): 浏览器对象模型， 操作浏览器的方法 DOM(document object model)：文档对象模型， 操作html,css的方法 js和html的两种结合方式 12345&lt;!-- 方法1：在html中编写 --&gt;&lt;script type=\"text/javascript\"&gt; js代码; &lt;/script&gt;&lt;!-- 方法2：在html中引用外部js文件 --&gt;&lt;script type=\"text/javascript\" src=\"1.js\"&gt;&lt;/script&gt; script标签最好放在body标签后。因为html是自上到下解析的，如果将script标签放在head中，而我们js代码需要操作body中html代码的一些数据，就不能操作成功。 变量 定义变量:使用关键字var 查看变量的数据类型：typeof() 五个原始类型：Undefined、Null、Boolean、Number 和 String 12345var str = \"abc\"; //stringvar num = 123; //numbervar flag = true; //boolvar v; //undifined,定义变量时没有赋值var date = new Date(); //object, 获取对象的引用 ECMA将null设置成了object类型 运算符 js里面不区分整数和小数 123var a = 123;var b = a/1000 // b = 0.123var c = b*1000 // c = 123 字符串的相加和相减的操作 123var s1 = '123';var s2 = s1 + 1; // 相加做字符串的连接, s2 = '1231'var s3 = s1 - 1; // 相减会做类型转换(若不能转为number型，则提示NaN，表示不是数字)，然后做减法， s3 = 122 == 和 === 作判断的区别 1234var a = '1';var b = 1;var c = (a == b) // true, '=='只比较值var d = (a == b) // false, '==='比较值和类型 直接向页面输出的语句(变量，html代码) 12document.write(\"hello world\"); //打印hello worlddocument.wirte(\"&lt;hr/&gt;\"); //打印一条直线 函数 js在预处理阶段会将函数、变量的声明提前 函数的定义1234567891011121314// 方法1function 方法名(参数列表) {}// 方法2：匿名函数var 方法名 = function(参数列表) { 方法体、返回值;}// 方法3：封闭函数, 一个一开始就执行的不用命名的函数(function (){})(); // 可以在function前加上“~”和“!”来定义匿名函数// 方式4：动态函数,使用内置对象Function 用的少var add = new Function(\"参数列表\",\"方法体和返回值\"); 全局函数不属于任何一个对象，可以直接写名称使用 alert(str); eval(str)： 执行js代码 encodeURI()：对字符进行编码 decodeURI()：对字符进行解码 encodeURIComponent() 和 decodeURIComponent() isNaN():判断当前字符串是否不是数字 parseInt()：转为数字 splice(): 删除，并添加元素 函数的重载 js里面是否存在重载？(面试题目)答：js里面不存在重载, 但是可以通过其他方式模拟重载的效果 （通过aruguments数组来实现） 12345678910111213141516171819function add1() { // 2个参数 if(arguments.length == 2) { return arguments[0]+arguments[1]; } // 3个参数 else if (arguments.length == 3) { return arguments[0]+arguments[1]+arguments[2]; } // 4个参数 else if (arguments.length == 4) { return arguments[0]+arguments[1]+arguments[2]+arguments[3]; } // 其他 else { return 0; }} 常用对象String对象123456// 创建String对象var str = \"abc\";var str = new string(\"abc\"); // length属性：获取串的长度var len = str.length 与字符的显示相关的方法 方法 功能 bold() 加粗 fontcolor() 设置字符串的颜色 fontsize() 设置字体的大小 link() 将字符串显示成超链接 sub()/sup() 下标和上标 处理字符串的方法 方法 功能 concat() 连接字符串 charAt() 返回指定指定位置的字符串 split() 切分字符串，成数组 replace(old,new) 替换字符串 substr(index, num) 从第index位开始，截取numb个字符 substring(start, end) 从start开始，到end结束，不包括end Array对象12345678// 创建数组var arr = []; var arr1 = [1,2,3];var arr2 = new Array(3); var arr3 = new Array(1,2,3); // length属性：记录数组的长度var len = arr.length; concat())： 数组的连接 1var arr = arr1.concat(arr2) join()：根据指定的字符分割数组 12var arr = \"abc\";document.write(arr13.join(\"-\")); // a-b-c push():向数组末尾添加元素，返回数组的新的长度 如果添加的是一个数组，这个时候把数组当做一个整体字符串添加进去 1234567var arr = new Array(3);arr[0] = \"aa\";arr[1] = \"bb\";arr[2] = \"cc\";document.write(arr.push(\"dd\")); // 4document.write(arr); // aabbccdd pop()：删除最后一个元素，返回删除的那个元素 1234567var arr = new Array(3);arr[0] = \"aa\";arr[1] = \"bb\";arr[2] = \"cc\";document.write(arr.pop()); // ccdocument.write(arr.length); // 2 reverse():颠倒数组中的元素的顺序,返回颠倒后的数组 123456var arr = new Array(3);arr[0] = \"aa\";arr[1] = \"bb\";arr[2] = \"cc\";document.write(arr.reverse()); // ccbbaa Date对象123456789101112131415161718192021222324252627// 获取当前时间var date = new Date();document.write(date.toLocaleString());// getFullYear(): 获取当前的年方法getFullYear()document.write(date.toLocaleString());// getMonth()：获取当前的月,返回的是 0-11月，如果想要得到准确的值，加1document.write(\"month: \"+(date.getMonth()+1)));// getDay()：星期,返回的是 (0 ~ 6)document.write(\"week: \"+date.getDay());// getDate()：得到当前的天 1-31document.write(\"day: \"+date.getDate());// getHours()：获取小时document.write(\"hour: \"+date.getHours());// getMinutes()：分钟document.write(\"minute: \"+date.getMinutes());// getSeconds(): 秒document.write(\"second: \"+date.getSeconds());// getTime(): 返回的是1970 1 1 至今的毫秒数 Math对象Math对象里面的都是静态方法，使用可以直接使用 Math.方法() 12345678ceil(x): 向上舍人floor(x)：向下舍人round(x)：四舍五入random()：得到随机数（伪随机数）// 得到0-9的随机数Math.random()*10Math.floor(Math.random()*10)); Reg正则对象 创建 12var reg = new RegExp(\"正则表达式\");var reg = /正则表达式/; test(参数)方法: 验证指定的字符串是否符合正则定义的规范 JSON 对象转Json：JSON.stringify() Json转对象：JSON.parse() BOM Browser Object Model 浏览器对象模型, 将浏览器的各个组成部分封装成对象。 navigator： 获取客户机的信息（浏览器的信息） navigator.appName document.write(navigator.appName); screen: 获取屏幕的信息， screen.width, screen.height location: 请求url地址 href属性: 获取/设置url地址 search属性：获取地址的参数部分（url中?及其以后的部分） hash属性：获取页面描点/哈希值（url中#及其以后的部分） history：请求的url的历史记录 到访问的上一个页面history.back();history.go(-1); 到访问的下一个页面history.forward();history.go(1); window: 窗口对象 顶层对象（所用的bom对象都是在window里面操作的） window对象的方法 window.alert() : 页面弹出一个框，显示内容 confirm()： 确认框 var flag = window.confirm(“显示的内容”); prompt()： 输入的对话框 window.prompt(“please input : “,”0”); window.prompt(“在显示的内容”,”输入框里面的默认值”); open() : 打开一个新的窗口 open(“打开的新窗口的地址url”,””,”窗口特征，比如窗口宽度和高度”) window.open(“hello.html”,””,”width=200,height=100”); close(): 关闭窗口(浏览器兼容性比较差) window.close(); 做定时器 setInterval(“js代码”,毫秒数) 1秒=1000毫秒 每隔指定的时间执行一次js代码 window.setInterval(“alert(‘123’);”,3000); setTimeout(“js代码”,毫秒数) 运行指定时间后，执行且仅执行一次js代码 clearInterval(): 清除setInterval设置的定时器 clearInterval(传入setInterval方法的返回值); clearTimeout() : 清除setTimeout设置的定时器 clearTimeout(传入setTimeout方法的返回值); DOM 概念： Document Object Model 文档对象模型 将标记语言文档的各个组成部分，封装为对象。 可以使用这些对象，对标记语言文档进行CRUD的动态操作 W3C DOM 标准被分为 3 个不同的部分： 核心 DOM - 针对任何结构化文档的标准模型 Document：文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment:注释对象 Node：节点对象，其他5个的父对象 XML DOM - 针对 XML 文档的标准模型 HTML DOM - 针对 HTML 文档的标准模型 核心DOM模型： Document：文档对象 创建(获取)：在html dom模型中可以使用window对象来获取 window.document document 方法： 获取Element对象： getElementById() ： 根据id属性值获取元素对象。id属性值一般唯一 getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组 getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组 getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组 创建其他DOM对象： createAttribute(name) createComment() createElement() createTextNode() 属性 referrer属性：记录上一个跳转页面的地址（需要服务器环境） Element：元素对象 获取/创建：通过document来获取和创建 方法： removeAttribute()：删除属性 setAttribute()：设置属性 Node：节点对象，其他5个的父对象 特点：所有dom对象都可以被认为是一个节点 方法： CRUD dom树： appendChild()：向节点的子节点列表的结尾添加新的子节点。 removeChild() ：删除（并返回）当前节点的指定子节点。 replaceChild()：用新节点替换一个子节点。 属性： parentNode 返回节点的父节点。 HTML DOM 标签体的设置和获取：innerHTML 使用html元素对象的属性 控制元素样式 使用元素的style属性来设置 如：div1.style.fontSize = &quot;20px&quot;; 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。 事件监听机制 概念：某些组件被执行了某些操作后，触发某些代码的执行。 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了 事件源：组件。如： 按钮 文本输入框… 监听器：代码。 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。 常见的事件： 点击事件： onclick：单击事件 ondblclick：双击事件 焦点事件 onblur：失去焦点 onfocus:元素获得焦点。 加载事件： onload：一张页面或一幅图像完成加载。 鼠标事件： onmousedown 鼠标按钮被按下。 onmouseup 鼠标按键被松开。 onmousemove 鼠标被移动。 onmouseover 鼠标移到某元素之上。 onmouseout 鼠标从某元素移开。 键盘事件： onkeydown 某个键盘按键被按下。 onkeyup 某个键盘按键被松开。 onkeypress 某个键盘按键被按下并松开。 选择和改变 onchange 域的内容被改变。 onselect 文本被选中。 表单事件： onsubmit 确认按钮被点击。 onreset 重置按钮被点击。 web本地存储html5提供了两种在客户端存储数据的新方法，以前都是用cookie。 对于不同的网站数据存储于不同的区域，并且一个网站只能访问其自身的数据 localStorage: 没有时间限制 sessionStorage: 针对一个session的数据存储 使用js提供了localStorage、sessionStorage两个类对象，可以直接调用相关方法即可 localStorage、sessionStorage存储的数据都是key-value结构，而且value只能是字符串。 相关方法： setItem getItem removeItem","link":"/2020/03/18/js/javascript/"},{"title":"JQuery","text":"JQuery对象在操作时，更加方便。 JQuery对象和js对象方法不通用的. 两者相互转换 jq – &gt; js : jq对象[索引] jq对象.get(索引) js – &gt; jq : $(js对象) 基本操作 事件绑定1234//1.获取b1按钮$(\"#b1\").click(function(){ alert(\"abc\");}); 入口函数 $(function() { ... }); window.onload 和 $(function)区别 window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉 $(function)可以定义多次的。 样式控制：css方法12$(\"#div1\").css(\"background-color\",\"red\");$(\"#div1\").css(\"backgroundColor\",\"pink\"); // 可以选中backgroundColor按Ctrl检查是否写错 选择器 筛选具有相似特征的元素(标签) 基本选择器 标签选择器（元素选择器） 语法： $(&quot;html标签名&quot;) 获得所有匹配标签名称的元素 id选择器 语法：$(&quot;#id的属性值&quot;) 获得与指定id属性值匹配的元素 类选择器 语法： $(&quot;.class的属性值&quot;)获得与指定的class属性值匹配的元素 并集选择器： 语法： $(&quot;选择器1,选择器2....&quot;)获取多个选择器选中的所有元素 层级选择器 后代选择器 语法： $(&quot;A B &quot;)选择A元素内部的所有B元素 子选择器 语法： $(&quot;A &gt; B&quot;)选择A元素内部的所有直接子元素B， 不包括孙子元素B 属性选择器 属性名称选择器 语法： $(&quot;A[属性名]&quot;)包含指定属性的选择器 属性选择器 语法： $(&quot;A[属性名='值']&quot;)包含指定属性等于指定值的选择器 复合属性选择器 语法： $(&quot;A[属性1][属性2]...&quot;) 包含多个属性条件的选择器 过滤选择器 首元素选择器 语法：:first 获得选择的元素中的第一个元素 尾元素选择器 语法：:last 获得选择的元素中的最后一个元素 非元素选择器 语法：:not(selector) 不包括指定内容的元素 偶数选择器 语法：:even 偶数，从 0 开始计数 奇数选择器 语法：:odd 奇数，从 0 开始计数 等于索引选择器 语法：:eq(index)指定索引元素 大于索引选择器 语法：:gt(index)大于指定索引元素 小于索引选择器 语法：:lt(index) 小于指定索引元素 标题选择器 语法：:header 获得标题（h1~h6）元素，固定写法 表单过滤选择器 可用元素选择器 语法：:enabled 获得可用元素 不可用元素选择器 语法：:disabled 获得不可用元素 选中选择器 语法： :checked 获得单选/复选框选中的元素 选中选择器 语法：:selected获得下拉框选中的元素 DOM操作 内容操作 html(): 获取/设置元素的标签体内容 text(): 获取/设置元素的标签体纯文本内容 val()： 获取/设置元素的value属性值 属性操作 通用属性操作 attr(): 获取/设置元素的属性 removeAttr():删除属性 prop():获取/设置元素的属性 removeProp():删除属性 attr和prop区别？ 如果操作的是元素的固有属性，则建议使用prop 如果操作的是元素自定义的属性，则建议使用attr 注：使用attr获取不到单选框/复选框的checked/selected属性， 对class属性操作 addClass():添加class属性值 removeClass():删除class属性值 toggleClass():切换class属性 判断如果元素对象上存在指定class则删除，不存在则添加 CRUD操作: append():父元素将子元素追加到末尾 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾 prepend():父元素将子元素追加到开头 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头 appendTo(): 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾 prependTo()： 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头 after():添加元素到元素后边 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系 before():添加元素到元素前边 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 insertAfter() 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系 insertBefore() 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 remove():移除元素 对象.remove():将对象删除掉 empty():清空元素的所有后代元素。 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点 clone()：复制一个元素 JQuery动画 三种方式显示和隐藏元素 默认显示和隐藏方式 show([speed,[easing],[fn]]) speed：动画的速度。 三个预定义的值(“slow”,”normal”, “fast”)或表示动画时长的毫秒数值(如：1000) easing：用来指定切换效果，默认是”swing”，可用参数”linear” swing：动画执行时效果是 先慢，中间快，最后又慢 linear：动画执行时速度是匀速的 fn：在动画完成时执行的函数，每个元素执行一次。 hide([speed,[easing],[fn]]) toggle([speed],[easing],[fn]) 滑动显示和隐藏方式 slideDown([speed],[easing],[fn]) slideUp([speed,[easing],[fn]]) slideToggle([speed],[easing],[fn]) 淡入淡出显示和隐藏方式 fadeIn([speed],[easing],[fn]) fadeOut([speed],[easing],[fn]) fadeToggle([speed,[easing],[fn]]) 遍历 js的遍历方式 for循环 jq的遍历方式 jq对象.each(callback) 语法： jquery对象.each(function(){}); this：集合中的每一个元素对象 jquery对象.each(function(index,element){}); index: 就是元素在集合中的索引 element：就是集合中的每一个元素对象 回调函数返回值： true: 如果当前function返回为false，则结束循环(break)。 false: 如果当前function返回为true，则结束本次循环，继续下次循环(continue) $.each(object, [callback]) object：要遍历的对象 for..of : for(元素对象 of 容器对象) jquery 3.0 版本之后提供的方式 事件绑定 jquery标准的绑定方式 jq对象.事件方法(回调函数)； 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 表单对象.submit();//让表单提交 输入框对象.focus(); // 让输入框获得焦点 on绑定事件/off解除绑定 jq对象.on(&quot;事件名称&quot;,回调函数) jq对象.off(&quot;事件名称&quot;) 如果off方法不传递任何参数，则将组件上的所有事件全部解绑 事件切换：toggle jq对象.toggle(fn1,fn2...) 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2….. 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。 1&lt;script src=\"../js/jquery-migrate-1.0.0.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; 插件：增强JQuery的功能 实现方式： $.fn.extend(object) 增强通过Jquery获取的对象的功能 $() $.extend(object) 增强JQeury对象自身的功能 $/jQuery 案例 广告显示和隐藏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;广告的自动显示与隐藏&lt;/title&gt; &lt;style&gt; #content{width:100%;height:500px;background:#999} &lt;/style&gt; &lt;!--引入jquery--&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery-3.3.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; /* 需求： 1. 当页面加载完，3秒后。自动显示广告 2. 广告显示5秒后，自动消失。 分析： 1. 使用定时器来完成。setTimeout (执行一次定时器) 2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display 3. 使用 show/hide方法来完成广告的显示 */ //入口函数，在页面加载完成之后，定义定时器，调用这两个方法 $(function () { //定义定时器，调用adShow方法 3秒后执行一次 setTimeout(adShow,3000); //定义定时器，调用adHide方法，8秒后执行一次 setTimeout(adHide,8000); }); //显示广告 function adShow() { //获取广告div，调用显示方法 $(\"#ad\").show(\"slow\"); } //隐藏广告 function adHide() { //获取广告div，调用隐藏方法 $(\"#ad\").hide(\"slow\"); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 整体的DIV --&gt; &lt;div&gt; &lt;!-- 广告DIV --&gt; &lt;div id=\"ad\" style=\"display: none;\"&gt; &lt;img style=\"width:100%\" src=\"../img/adv.jpg\" /&gt; &lt;/div&gt; &lt;!-- 下方正文部分 --&gt; &lt;div id=\"content\"&gt; 正文部分 &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 抽奖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;jquery案例之抽奖&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery-3.3.1.min.js\"&gt;&lt;/script&gt; &lt;script language='javascript' type='text/javascript'&gt; /* 分析： 1. 给开始按钮绑定单击事件 1.1 定义循环定时器 1.2 切换小相框的src属性 * 定义数组，存放图片资源路径 * 生成随机数。数组索引 2. 给结束按钮绑定单击事件 1.1 停止定时器 1.2 给大相框设置src属性 */ var imgs = [\"../img/man00.jpg\", \"../img/man01.jpg\", \"../img/man02.jpg\", \"../img/man03.jpg\", \"../img/man04.jpg\", \"../img/man05.jpg\", \"../img/man06.jpg\", ]; var startId;//开始定时器的id var index;//随机角标 $(function () { //处理按钮是否可以使用的效果 $(\"#startID\").prop(\"disabled\",false); $(\"#stopID\").prop(\"disabled\",true); //1. 给开始按钮绑定单击事件 $(\"#startID\").click(function () { // 1.1 定义循环定时器 20毫秒执行一次 startId = setInterval(function () { //处理按钮是否可以使用的效果 $(\"#startID\").prop(\"disabled\",true); $(\"#stopID\").prop(\"disabled\",false); //1.2生成随机角标 0-6 index = Math.floor(Math.random() * 7);//0.000--0.999 --&gt; * 7 --&gt; 0.0-----6.9999 //1.3设置小相框的src属性 $(\"#img1ID\").prop(\"src\",imgs[index]); },20); }); //2. 给结束按钮绑定单击事件 $(\"#stopID\").click(function () { //处理按钮是否可以使用的效果 $(\"#startID\").prop(\"disabled\",false); $(\"#stopID\").prop(\"disabled\",true); // 1.1 停止定时器 clearInterval(startId); // 1.2 给大相框设置src属性 $(\"#img2ID\").prop(\"src\",imgs[index]).hide(); //显示1秒之后 $(\"#img2ID\").show(1000); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 小像框 --&gt; &lt;div style=\"border-style:dotted;width:160px;height:100px\"&gt; &lt;img id=\"img1ID\" src=\"../img/man00.jpg\" style=\"width:160px;height:100px\"/&gt; &lt;/div&gt; &lt;!-- 大像框 --&gt; &lt;div style=\"border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px\"&gt; &lt;img id=\"img2ID\" src=\"../img/man00.jpg\" width=\"800px\" height=\"500px\"/&gt; &lt;/div&gt; &lt;!-- 开始按钮 --&gt; &lt;input id=\"startID\" type=\"button\" value=\"点击开始\" style=\"width:150px;height:150px;font-size:22px\"&gt; &lt;!-- 停止按钮 --&gt; &lt;input id=\"stopID\" type=\"button\" value=\"点击停止\" style=\"width:150px;height:150px;font-size:22px\"&gt; &lt;/body&gt; &lt;/html&gt;","link":"/2020/03/18/js/jquery/"},{"title":"NodeJs","text":"Node.js是一个Javascript运行环境(runtime)。发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。Node.js 的包管理器 npm，是全球最大的开源库生态系统。官网：https://nodejs.org 线程模型和事件循环线程模型Apache+Tomcat(6,7,8,9)运行 req来袭 thread应对 req处理完后，thread释放 线程处理模式就是重复以上三个步骤，来处理来自客户端的各种请求，当有大量客户端的请求来袭时，服务器消耗的资源也会随之增加。 事件循环Node.js服务运行 开一个事件等待循环（event-loop） req来袭 放入事件处理队列中，然后继续等待新的req请求 req处理完成后，调用I/O，结束req(非阻塞调用) 事件循环处理模式中，线程不用等待req处理完后在进行下个req的处理，而是将所有的req请求放入到队列之中，然后采用非同步的方式，等待req处理完后再调用I/O资源，然后结束req。 命令123456$ node&gt; console.log(\"Helo World.\");&gt; .help&gt; .exit$ node filename.js 非阻塞处理 阻塞 12345var start = new Date().getTime();while(new Date().getTime() &lt; start + 3000);// 3s后打印console.log(\"hello world\"); 非阻塞 1234// 程序一运行就打印world, 3s后打印hellosetTimeout(() =&gt; console.log(\"hello\"), 3000)console.log(\"world\") 实现http服务器123456789101112131415161718192021222324252627282930const fs = require(\"fs\"); // 引入fs库（文件系统）const http = require(\"http\"); // 引入http库const config = require(\"./config\").config // 引入configconst server = http.createServer((req, resp) =&gt; { // 拼接资源全路径 var filename = null; if (req.url == \"/\") { filename = \"./page/index.html\" } else { filename = \"./page\" + req.url; } // 读取资源, 并发送响应 fs.readFile(filename, \"utf-8\", function (err, data) { resp.setHeader(\"Content-type\", \"text/html\"); if (err) { resp.statusCode = 404; resp.end(\"not found!\"); } else { resp.statusCode = 200; resp.end(data); } })});server.listen(config.port, config.hostname, () =&gt; { console.log(`Server runing at http://${config.hostname}:${config.port}/`)}) npm包管理工具123$ npm install moduleName # 当前项目$ npm install -g moduleName # 全局安装$ npm install nrmNPM registry manager 123$ npm install -g nrm # 安装npm$ nrm ls # 查看源$ nrm use 源 # 切换下载源 ejs使用 “E” 代表 “effective”，即【高效】。EJS 是一套简单的模板语言，帮你利用普通的 JavaScript 代码生成 HTML 页面。EJS 没有如何组织内容的教条；也没有再造一套迭代和控制流语法；有的只是普通的 JavaScript 代码而已。 Nodejs操作MongoDBPromise承诺优点 使用Promise可以解决回调地狱问题 Promise对象API简洁，操作简单 Promise常用API实例方法： then()：得到异步任务的正确结果 catch()：获取异常信息 finally()：成功与否最终都会执行的方法 类方法： Promise.all()：并发处理多个异步任务，所有任务都执行完成后，返回所有结果 Promise.race()：并发处理多个异步任务，只要有一个任务完成就返回结果，并且只有这个返回的结果。 123456789101112131415161718192021222324// 更新数据库操作function updateDB(sql) { let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(`${sql} update ok!`); resolve(`${sql} ok!`); }, 500); }); return p; // 返回promise对象}updateDB(\"sql1\") .then(() =&gt; updateDB(\"sql2\")) .then(() =&gt; updateDB(\"sql3\"))let p1 = updateDB(\"sql1\");let p2 = updateDB(\"sql2\");let p3 = updateDB(\"sql3\");Promise.all([p1, p2, p3]) .then((res) =&gt; console.log(res));Promise.race([p1, p2, p3]) .then((res) =&gt; console.log(res)); async/awaitES7引入的语法，方便进行异步操作 async关键字用于函数上，async函数的返回值是Promise对象 await关键字用于async函数中，用于获取异步请求的结果 12345678async function updateAll() { // 顺序执行这三个异步更新请求 let res1 = await updateDB(\"sql1\"); let res2 = await updateDB(\"sql2\"); let res3 = await updateDB(\"sql3\"); console.log(res1 + res2 + res3);}updateAll();","link":"/2021/03/06/js/nodejs/"},{"title":"VueJs","text":"tips 开发单页面网页（spa） html不区分大小写，vue中的使用驼峰驼峰命名的属性，用到html中大写字母一般会变为- css中的id/class区分大小，支持驼峰命名 框架与库 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 MVC与MVVM MVC是后端分层的概念， MVVM（Model-View-ViewModel）是前端视图层的概念。将视图 UI 和业务逻辑分开，主要目的是分离视图（View）和模型（Model） 引入Vue12345&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; 插值表达式数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值，Mustache 标签将会被替代为对应数据对象上属性的值。无论何时，绑定的数据对象上属性发生了改变，插值处的内容都会更新（响应式的）。 12345678910111213141516171819&lt;body&gt;&lt;div id=\"app\"&gt; &lt;!-- 渲染数据 --&gt; message: {{message}} &lt;br&gt; number: {{number + 1}} &lt;br&gt; {{ true ? 'YES' : 'NO' }}&lt;/div&gt;&lt;/body&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; // 创建vue对象 var vm = new Vue({ el: '#app', // 表示该vue对象，要控制id为app的标签 data: { message: 'hello vuejs', number: 1 } })&lt;/script&gt; vue-devtools浏览器插件安装插件后需要手动勾选允许访问文件系统 html文件应用的vue.js，必须是开发版的 VueJs指令v-cloak指令用于解决插值表达式闪烁的问题（就是在页面渲染前，显示插值表达式的问题） 123456789&lt;style&gt; [v-cloak] {display: none; }&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;p v-cloak&gt; message: {{message}} &lt;/p&gt;&lt;/div&gt; v-text与v-html用于渲染数据 v-text：将数据当作字符串显示在页面上 v-html：将数据当作html代码解析 注意：它们都会覆盖标签体中的内容 123&lt;div v-html=\"message\"&gt;&lt;/div&gt;&lt;div v-text=\"message\"&gt;&lt;/div&gt; v-on与修饰符v-on指令用于事件绑定, 可简写成@ 事件 keydown -&gt; keypress -&gt; keyup mouseenter 事件修饰符 .stop 阻止事件传播 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 按键修饰符： 监听键盘事件时添加按键修饰符 .enter .tab .delete (捕获 “删除” 和 “退格” 键) .esc .space .up .down .left .right .ctrl .alt .shift .meta 自定义按键修饰符 1Vue.config.keyCodes.f2 = 113; // value指定为对应得keyCode值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body&gt;&lt;div id=\"app\"&gt; &lt;h3&gt;v-on:click&lt;/h3&gt; &lt;button v-on:click=\"fOnClick('v-on:click')\"&gt;v-on:click&lt;/button&gt; &lt;h3&gt;v-on:keydown（只允许输入数字）&lt;/h3&gt; &lt;input type=\"text\" v-on:keydown=\"fKeyDown($event)\"&gt;&lt;!-- $event vuejs的event对象 跟js的event对象一样 --&gt; &lt;h3&gt;按键选择器(选择enter)&lt;/h3&gt; &lt;input type=\"text\" v-on:keydown.enter=\"fKeyEnter\"&gt; &lt;h3&gt;v-on:fMouseOver&lt;/h3&gt; &lt;div @mouseover=\"divMouseOver\" style=\"width:300px;height:220px;background-color: red\"&gt; &lt;!-- stop属性: 相当于event.stopPropagation()，阻止事件传播 --&gt; &lt;button @mouseover.stop=\"btnMouseOver($event)\"&gt;btn&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; new Vue({ el: '#app', methods: { fOnClick: function (msg) { alert(msg); }, fKeyDown: function (event) { var keycode = event.keyCode; if (keycode &lt; 48 || keycode &gt; 57) { // 不要执行与事件关联的默认动作 event.preventDefault(); } }, fKeyEnter: function() { alert(\"您按下了回车。。。\") }, divMouseOver: function () { alert(\"鼠标移动到div上了。。。\"); }, btnMouseOver: function (event) { alert(\"鼠标移动到button上了。。。\"); // 停止事件传播， 就是不在触发外层div的onmouseover事件 // event.stopPropagation(); } } })&lt;/script&gt; v-model可以实现表单元素和Model中的数据的双向绑定 123456789101112131415&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h2&gt; {{msg}}&lt;/h2&gt; &lt;input type=\"text\" v-model=\"msg\" style=\"width: 500px; height: 35px; font-size: 18px;\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue({ el: \"#app\", data: { msg: \"v-model实现数据的双向绑定\" } });&lt;/script&gt; v-bind用于绑定属性，可简写成: 绑定属性 12345678910111213141516&lt;body&gt; &lt;div id=\"app\"&gt; &lt;a v-bind=\"{href: 'https://www.baidu.com/s?wd=' + word}\"&gt; &lt;input type=\"button\" v-bind:value=\"'点击搜索' + word\"&gt; &lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue({ el: \"#app\", data: { word: \"java\" } });&lt;/script&gt; 使用class样式 12345678910111213141516171819202122232425262728293031323334&lt;head&gt; &lt;style&gt; .pink { color: pink; } .thin { font-weight: 100; } #size { font-size: 40px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h2 :class=\"'pink'\" :id=\"'size'\"&gt;引用单个样式&lt;/h2&gt; &lt;h2 :class=\"['pink', 'thin']\"&gt;使用数组&lt;/h2&gt; &lt;h2 :class=\"flag ? 'pink' : ''\"&gt;使用三元运算符&lt;/h2&gt; &lt;h2 :class=\"{'pink': true, 'thin': false}\"&gt;使用对象&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue({ el: \"#app\", data: { word: \"java\", flag: true, style: {color: 'pink', 'font-weight': '100'} } });&lt;/script&gt; 使用内联样式 123&lt;!-- 属性名有'-'的必须使用引号 --&gt;&lt;h2 :style=\"{color: 'pink', 'font-weight': '100'}\"&gt;使用内联样式&lt;/h2&gt;&lt;h2 :style=\"style\"&gt;引用data中定义的样式&lt;/h2&gt; v-for和key用于遍历数组、对象…， 在特殊情况下可能需要使用:key指定唯一的key 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;body&gt;&lt;div id=\"app\"&gt; &lt;!-- fori --&gt; &lt;span v-for=\"item,idx in 5\"&gt; {{idx}},{{item}} &lt;/span&gt;&lt;br&gt;&lt;br&gt; &lt;!-- 遍历数组 --&gt; &lt;span v-for=\"item in arr\"&gt; {{item}} &lt;/span&gt;&lt;br&gt;&lt;br&gt; &lt;!-- 遍历对象 --&gt; &lt;span v-for=\"prop in person\"&gt; {{prop}} &lt;/span&gt;&lt;br&gt;&lt;br&gt; &lt;table border=\"0px\"&gt; &lt;tr&gt; &lt;td&gt;checkbox&lt;/td&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;name&lt;/td&gt; &lt;td&gt;age&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;tr v-for=\"(person, idx) in persons\" :key=\"person.id\"&gt; &lt;!-- :key， 可以指定box的key(默认为第几个), 指定为person.id则可以将这个person和box绑定在一起 --&gt; &lt;td&gt;&lt;input type=\"checkbox\"&gt;&lt;/td&gt; &lt;td&gt;{{person.id}}&lt;/td&gt; &lt;td&gt;{{person.name}}&lt;/td&gt; &lt;td&gt;{{person.age}}&lt;/td&gt; &lt;td&gt;&lt;input type=\"button\" v-on:click=\"deleteByIdx(idx)\" value=\"delete\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\"&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" v-model=\"id\"&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" v-model=\"name\"&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" v-model=\"age\"&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"button\" v-on:click=\"add\" value=\"add\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue({ el: '#app', data: { arr: [1, 2, 3, 4, 5], person: {id:0, name:'tt', age:18}, persons: [ {id:0, name:'tt', age:18}, {id:1, name:'tt', age:18}, ], id: null, name: null, age: null }, methods: { add() { this.persons.push({id: this.id, name: this.name, age: this.age}); }, deleteByIdx(idx) { // ?: 方法名为delete不能成功执行 this.persons.splice(idx, 1); } } })&lt;/script&gt; v-if和v-show v-if：每次都会删除重新创建元素，频繁操作性能浪费 v-show：只是切换了元素的display属性值，不会删除重建，但有初始消耗（不管显不显示都会创建元素） 1234567891011121314151617&lt;body&gt;&lt;div id=\"app\"&gt; &lt;button @click=\"flag = !flag\"&gt;切换&lt;/button&gt;&lt;br&gt; &lt;span v-if=\"flag\"&gt;hello&lt;/span&gt; &lt;span v-show=\"flag\"&gt;world&lt;/span&gt;&lt;/div&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; new Vue({ el:'#app', data:{ flag:true } });&lt;/script&gt; 自定义指令官方文档： https://cn.vuejs.org/v2/guide/custom-directive.html 钩子函数： bind： 指令第一次绑定到元素时调用 inserted：被绑定元素插入到dom中时调用 updated：当组件（VNode）更新时，会执行updated方法；可能会调用多次。 钩子函数的参数： el：被绑定了指令得那个元素，是一个原生得js对象 binding：一个对象，包含执行相关信息 name：指令名，不包括 v- 前缀。 value：指令的绑定值 ，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。 expression：字符串形式的指令表达式 钩子函数使用原则： 和样式相关的操作，一般都可以在bind中设置 和JS行为相关的操作，最好在inserted中执行 全局指令：聚焦输入框 123456789// 参数1：指令名称，使用时需加上'v-'// 参数2：是一个对象，该对象上有一些指令相关得函数，在特定得阶段执行特定得操作Vue.directive(\"focus\", { inserted: function (el) { el.focus(); }})// 使用&lt;input type=\"text\" v-focus&gt; 私有指令 123456789101112var vm = new Vue({ el: \"#app\", directives: { // 定义私有指令 \"color\": { bind: function(el, binding) { el.style.color = binding.value; } } }} // 使用&lt;input type=\"text\" v-color=\"'green'\"&gt; 函数简写 在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子 12345678910// 全局Vue.directive(\"color\", function(el, binding) { el.style.color = binding.value;})// 私有directives: { color (el, binding) { el.style.color = binding.value; }} 过滤器Vue.js 允许自定义过滤器，用来作一些常见的文本格式化。 过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。 管道符：| 私有/局部过滤器123456789101112131415161718192021222324&lt;div id=\"app\"&gt; {{new Date | dateFormat(\"yyyy-mm-dd\")}}&lt;/div&gt;&lt;/body&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; new Vue({ el: '#app', filters: { // 用于定义私有过滤器 dateFormat(dateStr, pattern) { var date = new Date(dateStr); var year = date.getFullYear(); var month = (date.getMonth() + 1).toString().padStart(2, \"0\"); var day = date.getDate().toString().padStart(2, \"0\"); if (pattern &amp;&amp; pattern.toLowerCase() === \"yyyy-mm-dd\") return `${year}-${month}-${day}`; else return \"格式错误！\"; } } })&lt;/script&gt; 全局过滤器12345678910111213141516171819202122232425&lt;div id=\"app\"&gt; {{new Date | dateFormat(\"yyyy-mm-dd\")}}&lt;/div&gt;&lt;/body&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; // 定义全局过滤器 Vue.filter('dateFormat', function(dateStr, pattern) { var date = new Date(dateStr); var year = date.getFullYear(); var month = (date.getMonth() + 1).toString().padStart(2, \"0\"); var day = date.getDate().toString().padStart(2, \"0\"); if (pattern &amp;&amp; pattern.toLowerCase() === \"yyyy-mm-dd\") return `${year}-${month}-${day}`; else return \"格式错误！\"; }); new Vue({ el: '#app' })&lt;/script&gt; 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用 Vue实例的生命周期官网文档 组件Component官网文档： https://cn.vuejs.org/v2/guide/components-registration.html 定义组件12345678910111213141516171819202122232425&lt;div id=\"app\"&gt; &lt;my-com1&gt;&lt;/my-com1&gt; &lt;my-com2&gt;&lt;/my-com2&gt;&lt;/div&gt;&lt;template id=\"mytpl\"&gt; &lt;h1&gt;这是我的第二个component!&lt;/h1&gt;&lt;/template&gt;&lt;script&gt; // 方式1 // 组件模板对象Vue.extend()，可以提到外部定义 Vue.component(\"myCom1\", Vue.extend({ // template中只能由一个根标签 template: \"&lt;h1&gt;这是我的第一个component！&lt;/h1&gt;\" })); // 方式2 Vue.component(\"myCom2\", { template: \"#mytpl\" // 直接引用html中定义的template }); let vm = new Vue({ el: \"#app\", });&lt;/script&gt; 其它拓展 data：是一个函数，并且必须返回一个对象，对象中的数据可读可写 props：是一个数组，可以指定组件拥有的属性，其属性值由父组件传递来 尽量保证只读不写，因为父组件每次渲染都会改变该值 methods directives filters 12345678910111213141516171819202122232425262728293031&lt;div id=\"app\"&gt; &lt;count id=\"count1\"&gt;&lt;/count&gt; &lt;count id=\"count2\"&gt;&lt;/count&gt;&lt;/div&gt;&lt;template id=\"tpl\"&gt; &lt;div&gt; &lt;button v-on:click=\"increment\"&gt;++count&lt;/button&gt; &lt;h1&gt;{{count}}&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 定义一个组件，实现点击按钮自增效果 Vue.component(\"count\", { props: [\"id\"], template: \"#tpl\", data: function() { return { count: 0} }, methods: { increment() { ++ this.count; } }, }); let vm = new Vue({ el: \"#app\", });&lt;/script&gt; 组件切换VueJS提供了component标签，它的 :is属性可以用来指定要展示的组件 123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;button v-on:click=\"componentId='login'\"&gt;登录组件&lt;/button&gt; &lt;button v-on:click=\"componentId='register'\"&gt;注册组件&lt;/button&gt; &lt;component :is=\"componentId\"&gt;&lt;/component&gt;&lt;/div&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; Vue.component(\"login\", { template: \"&lt;h2&gt;这是一个登录组件&lt;/h2&gt;\", }); Vue.component(\"register\", { template: \"&lt;h2&gt;这是一个注册组件&lt;/h2&gt;\", }); let vm = new Vue({ el: \"#app\", data: {componentId: \"login\"} });&lt;/script&gt; 父组件向子组件传值通过属性绑定的方式， 使用props属性来定义父组件传递过来的数据 1234567891011121314151617let vm = new Vue({ el: \"#app\", data: { msg: \"msg!\" }, components: { children: { template: \"&lt;h2&gt;{{myMsg}}&lt;/h2&gt;\", props: [\"parentMsg\"], data: function() { return { myMsg: this.parentMsg } } } }});// &lt;children :parent-msg=\"msg\"&gt;&lt;/children&gt; 子组件向父组件传值 通过事件绑定机制，自定义一个事件，并父组件将方法的引用，传递到子组件内部 子组件在内部调用父组件传递过来的方法，并传递数据this.$emit('方法名', 要传递的数据) 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id=\"app\"&gt; &lt;!-- 通过事件绑定机制，自定义一个事件 --&gt; &lt;children v-on:sunclick=\"show\"&gt;&lt;/children&gt; &lt;!-- 显示子组件的数据 --&gt; &lt;h2&gt;{{sunMsg}}&lt;/h2&gt;&lt;/div&gt;&lt;script&gt; // 定义一个组件模板对象 let children = { template: \"&lt;button @click='myclick'&gt;获取子组件的Message&lt;/button&gt;\", props: [\"parentMsg\"], data: function() { return { sunMsg: \"子组件Message！\" } }, methods: { myclick() { this.$emit(\"sunclick\", this.sunMsg); } } }; let vm = new Vue({ el: \"#app\", data: { sunMsg: \"\" }, methods: { show(data) { this.sunMsg = data; console.log(data); } }, components: { // \"组件名: 组件模板对象\"， \"children\": children children // 简写：默认组件名，为模板对象名 } });&lt;/script&gt; 使用ref属性获取组件的引用 ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件 $refs 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 $refs。 123456&lt;h2 ref=\"h2\"&gt;hello&lt;/h2&gt;&lt;comm ref=\"comm\"&gt;&lt;/comm&gt; &lt;!-- comm组件 --&gt;// vm.$refs.h2.innerText // h2标签的内容// vm.$refs.comm.msg // comm组件中的msg属性 Vue中的动画官网文档： https://cn.vuejs.org/v2/guide/transitions.html transition单元素过度 注意：如果你使用一个没有名字的&lt;transition&gt;，则 v- 是这些类名的默认前缀。如果你使用了 &lt;transition name=&quot;my&quot;&gt;，那么 v-enter 会替换为 my-enter。 1234567891011121314151617181920212223242526272829303132333435&lt;head&gt; &lt;style&gt; /* 进入前，离开后 */ .v-enter, .v-leave-to { opacity: 0; transform: translateX(80px); /* 在x轴移动 */ } /* 进入时，离开时 */ .v-enter-active, .v-leave-active { transition: all 0.8s ease; /* 持续时间...*/ } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;button v-on:click=\"flag = !flag\"&gt;切换&lt;/button&gt; &lt;!-- 将要设置过度效果的标签用transition标签包裹起来，用v-if/show控制显示与否 --&gt; &lt;transition&gt; &lt;h2 v-show=\"flag\"&gt;我是一个用于展示的动画切换效果的h2标签！&lt;/h2&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/body&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; let vm = new Vue({ el: \"#app\", data: { flag: true } });&lt;/script&gt; 结合第三方css库github： https://github.com/daneden/animate.css 特效展示：https://daneden.github.io/animate.css/ 12345678&lt;button v-on:click=\"flag = !flag\"&gt;切换&lt;/button&gt;&lt;!-- enter/leave-active-class指定入场/离场时的特效类 --&gt;&lt;!-- duration属性用于设置入场/离场的时间，:duration=\"{enter: 200, leave: 200}\" --&gt;&lt;transition enter-active-class=\"bounceIn\" leave-active-class=\"bounceOut\" duration=\"2000\"&gt; &lt;h2 v-show=\"flag\"&gt;我是一个用于展示的动画切换效果的h2标签！&lt;/h2&gt;&lt;/transition&gt; 结合钩子函数使用官方文档： https://cn.vuejs.org/v2/guide/transitions.html#JavaScript-%E9%92%A9%E5%AD%90 实现小球半场动画效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;head&gt; &lt;style&gt; /* 小球 */ .ball { width: 20px; height: 20px; border-radius: 50%; background-color: red; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h2&gt;模拟小球加入购物车效果&lt;/h2&gt; &lt;button v-on:click=\"flag = !flag\"&gt;加入购物车&lt;/button&gt; &lt;transition name=\"ball\" v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:after-enter=\"afterEnter\"&gt; &lt;div v-show=\"flag\" class=\"ball\" &gt;&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; let vm = new Vue({ el: \"#app\", data: { flag: false // 默认不显示 }, methods: { beforeEnter(el) { // 设置动画开始时小球的位置，保证小球在多次动画前都回到起始位置 el.style.transform = \"translate(0px, 0px)\"; }, enter(el, done) { // 没有实际意义，但是不写出不来动画效果 el.offsetWidth; // 设置动画持续时间，以及结束时小球的位置 el.style.transform = \"translate(300px, 600px)\"; el.style.transition = \"all 0.6s ease\"; // done就是afterEnter的引用, 必须调用 done(); }, afterEnter(el) { // 隐藏小球，并跳过后半场动画 this.flag = false; } }, });&lt;/script&gt; 列表过度使用transition-group标签将li标签包裹起来，并将transition-group标签渲染为ul标签 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;head&gt; &lt;style&gt; li { width: 100%; /* 消删除是，颜色显示不全的bug */ line-height: 50px; font-size: 20px; border: 1px dashed #999; margin: 10px; padding-left: 25px; } li:hover { background-color: pink; transition: all 0.5s ease; } .v-enter, .v-leave-to { opacity: 0; transform: translateY(100px); } .v-enter-active, .v-leave-active { transition: all 0.6s ease; } /* .v-move和.v-leave-active配合使用，实现列表后续的元素，渐渐地漂上来的效果 */ .v-move { transition: all 0.5s ease;} .v-leave-active { position: absolute;} &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div style=\"padding: 15px 30px;\"&gt; &lt;label for=\"\"&gt; ID: &lt;input type=\"text\" v-model=\"id\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; name: &lt;input type=\"text\" v-model=\"name\"&gt; &lt;/label&gt; &lt;label for=\"\"&gt; &lt;input type=\"button\" value=\"添加\" v-on:click=\"add\"&gt; &lt;/label&gt; &lt;/div&gt; &lt;!-- tag：设置渲染的标签，默认为span， appear：渐出效果 --&gt; &lt;transition-group tag=\"ul\" appear&gt; &lt;li v-for=\"person, idx of persons\" :key=\"person.id\" @click=\"del(idx)\"&gt;{{person.id}} ----- {{person.name}}&lt;/li&gt; &lt;/transition-group&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; let vm = new Vue({ el: \"#app\", data: { id: null, name: null, persons: [ {id: 0, name: \"tt1\"}, {id: 1, name: \"tt2\"}, {id: 2, name: \"tt3\"}, {id: 3, name: \"tt4\"} ] }, methods: { add() { this.persons.push({id: this.id, name: this.name}); this.id = this.name = null; }, del(idx) { this.persons.splice(idx, 1); } } });&lt;/script&gt;&lt;/html&gt; 多个组件过渡多个组件过渡，只需要用transition标签将动态组件标签包裹住，然后设置过度模式即可 123456789101112131415v&lt;style&gt; .v-enter, .v-leave-to { opacity: 0; transform: translateY(80px); } .v-enter-active, .v-leave-active { transition: all 0.5s ease; }&lt;/style&gt;&lt;!-- mode：out-in 设置组件切换模式先出后进--&gt;&lt;transition mode=\"out-in\"&gt; &lt;component :is=\"componentId\"&gt;&lt;/component&gt;&lt;/transition&gt; 路由Vue-routerVue-router官方文档： https://router.vuejs.org/zh/ 后端路由：就是将url地址对应到服务器上的资源 前端路由：在单页面应用程序中，通过改变url中的hash(#号后)来切换页面的方式，称作前端路由 url中hash的特点就是在发送http请求时，不会包含该hash相关内容。 入门案例￼定义login、register两个组件，对应两条路线；实现两条路线间的切换。 route-view：用于展示匹配到的组件 router-link：用于链接到指定的路线 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;style&gt; .myActive { color: red; font-size: 18px; } .v-enter, .v-leave-to { opacity: 0; transform: translateY(80px); } .v-enter-active, .v-leave-active { transition: all 0.5s ease; }&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;!-- 默认会渲染成一个a标签，也可用tag属性指定其它标签 --&gt; &lt;router-link to=\"/login\"&gt;登录&lt;/router-link&gt; &lt;!-- &lt;a href=\"#/login\"&gt;&lt;/a&gt; --&gt; &lt;router-link to=\"/register\"&gt;注册&lt;/router-link&gt; &lt;transition mode=\"out-in\"&gt; &lt;!-- 用于展示匹配到的组件 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt;&lt;/div&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"js/vue-router.js\"&gt;&lt;/script&gt;&lt;script&gt; let login = { template: \"&lt;h2&gt;这是一个登录组件！&lt;/h2&gt;\" } let register = { template: \"&lt;h2&gt;这是一个注册组件！&lt;/h2&gt;\" } // 创建一个VueRouter对象 const router = new VueRouter({ // routes 路由规则数组 routes: [ // path：请求路径， component：指定对应的组件模板对象，redirect前端重定向 {path: \"/\", redirect: \"/login\"}, {path: \"/login\", component: login}, {path: \"/register\", component: register} ], // 指定高亮css类，默认为router-link-active // 定位到对应的路由时，会将对应的route-link标签加上该类 linkActiveClass: \"myActive\" }) let vm = new Vue({ el: \"#app\", router: router // 指定VueRouter对象 });&lt;/script&gt; 使用请求参数 Vue/组件对象的$route.query中保存所有传统的请求参数， 如/getUser/?id=1 Vue/组件对象的$route.params中保存所有的路径参数（RESTful），如/user/1 12345678910111213141516let login = { template: \"&lt;h2&gt;这是一个登录组件！ --- 参数：{{$route.query.temp}}&lt;/h2&gt;\",}let register = { template: \"&lt;h2&gt;这是一个注册组件！ --- 参数：{{$route.params.temp}}&lt;/h2&gt;\"}const router = new VueRouter({ routes: [ // path：路线， component：指定路线对应的组件模板对象，redirect前端重定向 {path: \"/\", redirect: \"/login\"}, {path: \"/login\", component: login}, {path: \"/register/:temp\", component: register} // 使用路径参数 ]}) 路由嵌套1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div id=\"app\"&gt; &lt;!-- 展示用户模块 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;template id=\"account\"&gt; &lt;div&gt; &lt;h1&gt;用户模块&lt;/h1&gt; &lt;router-link to=\"/account/login\"&gt;登录&lt;/router-link&gt; &lt;router-link to=\"/account/register\"&gt;注册&lt;/router-link&gt; &lt;!-- 用于展示子路由 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; let account = { template: \"#account\" } let login = { template: \"&lt;h2&gt;这是一个登录组件! &lt;/h2&gt;\" } let register = { template: \"&lt;h2&gt;这是一个注册组件! &lt;/h2&gt;\" } let vm = new Vue({ el: \"#app\", // 路由 router: new VueRouter({ routes: [ {path: \"/\", redirect: \"/account\"}, { path: \"/account\", component: account, // 定义子路由 children: [ {path: \"login\", component: login}, {path: \"register\", component: register} ] } ] }) })&lt;/script&gt; 一路由多组件通过指定router-view的name属性实现上、左、右经典布局 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;style&gt; html, body { margin: 0px; padding: 0px; font-size: 24px; text-align: center; } .header { background-color: green; height: 80px; } /* flex布局 */ .container { display: flex; } .left { background-color: lightpink; height: 700px; flex: 2; } .main { background-color: pink; height: 700px; flex: 8; }&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class=\"container\"&gt; &lt;!-- router-view的name属性指定显示的组件名， 默认显示default--&gt; &lt;router-view name=\"left\"&gt;&lt;/router-view&gt; &lt;router-view name=\"main\"&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; &lt;script&gt; let headerBox = { template: `&lt;div class=\"header\"&gt;这是头部&lt;/div&gt;` } let leftBox = { template: `&lt;div class=\"left\"&gt;这是左边部分&lt;/div&gt;` } let mainBox = { template: `&lt;div class=\"main\"&gt;这是主体&lt;/div&gt;` } const router = new VueRouter({ routes: [ { path: \"/\", // 使用components指定该路由的所有组件 components: { \"default\": headerBox, // 默认组件，不写引号vue会帮我们补全 left: leftBox, // 左侧组件 main: mainBox // 主体组件 } } ] }) let vm = new Vue({ el: \"#app\", router: router });&lt;/script&gt;&lt;/html&gt; watch监控 watch是一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。 1234567891011121314let vm = new Vue({ el: \"#app\", router: router, watch: { \"$route.path\": function(newVal, oldVal) { console.log(newVal + \"---------------\" + oldVal); if (newVal === \"/login\") { console.log(\"欢迎进入登录页面！\"); } else if (newVal === \"register\") { console.log(\"欢迎进入注册页面！\"); } } }}); computed计算属性 计算属性的结果会被缓存下来，只有当其依赖的响应式属性变化才会重新计算。注意，如果某个依赖是非响应式属性，则计算属性是不会被更新的。 12345678910111213141516171819202122232425262728&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"num1\"&gt; + &lt;input type=\"text\" v-model=\"num2\"&gt; = &lt;input type=\"text\" v-model=\"result\"&gt; {{result2}}&lt;/div&gt;&lt;/body&gt;&lt;script src=\"js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; let vm = new Vue({ el: '#app', data: { num1: 0, num2: 0 }, computed: { // 使用箭头函数，则 this 不会指向这个组件的实例 // 不过我们可以将实例作为函数的第一个参数来访问 result: vm =&gt; parseInt(vm.num1) + parseInt(vm.num2), result2: function() { return parseInt(this.num1) + parseInt(this.num2); } }, })&lt;/script&gt; watch、computed和methods区别 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； Webpack4webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具。 可以处理js文件的依赖关系，js的建容问题 官方文档： https://www.webpackjs.com/concepts/ 网页中的静态资源常见的静态资源 JS：.js .jsx .coffee .ts CSS：.css .less .sass .scss Images：.jpg .png .gif .bmp .svg Fonts：.svg .ttf .eot .woff .woff2 模板文件：.ejs .jade .vue 网页中引入的静态资源多了以后有什么问题 网页加载速度慢， 因为 我们要发起很多的二次请求； 要处理错综复杂的依赖关系 如何解决上述两个问题 合并、压缩、精灵图、图片的Base64编码 可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系 打包JS文件在打包之前，需要安装这两个软件：npm i -g webpack webpack-cli webpack4默认打包的入口时src/index.js，出口是dist/main.js 打包方式1 直接命令行：webpack 入口 -o 出口 参数： --mode production：生产模式（默认），没有debug代码 --mode development：开发模式 如：webpack src/main.js -o dist/bundle.js 打包方式2 在项目根路径下创建webpack.config.js 12345678910111213let path = require(\"path\"); // 导入路径处理库module.exports = { // 配置项目入口 // 可以设置多个入口 entry: {home: 'home.js', about: 'about.js'} entry: path.join(__dirname, \"src/main.js\"), // 配置输出选项 output: { path: path.join(__dirname, \"dist\"), filename: \"bundle.js\" }, mode: \"development\"} 然后再运行webpack命令 loader loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript） 官网文档： https://www.webpackjs.com/concepts/loaders/ 实现打包css文件 安装npm i style-loader css-loader .... --save-dev 修改webpack.config.js 123456789101112131415module.exports = { // ...... // 配置第三方模块加载器 module: { rules: [ // 定义loader匹配规则 // 匹配到后，从从右往左调用loader模块 {test: /\\.css$/, use: [\"style-loader\", \"css-loader\"]}, {test: /\\.less$/, use: [\"style-loader\", \"css-loader\", \"less-loader\"]}, {test: /\\.scss$/, use: [\"style-loader\", \"css-loader\", \"scss-loader\"]} ] }} 在main.js使用import中引入css文件 1import \"./css/index.css\" 处理css中的路径问题（图片字体） 运行npm i url-loader file-loader --save-dev 在webpack.config.js中添加处理url路径的loader模块 12345678// 图片{ test: /\\.(png|jpg|gif|bmp|jpeg)$/, // 图片大小 &gt;= limit时，不转为base64格式, 其文件名按name指定的格式 use: [\"url-loader?limit=10240&amp;name=[hash:8]-[name].[ext]\"]},// 字体{test: /\\.(ttf|eot|svg|woff|woff2)$/, use: \"url-loader\", } 使用babel处理高级JS语法 源码： https://github.com/babel/babel-loader 安装相关loader：cnpm install -D babel-loader @babel/core @babel/runtime @babel/plugin-transform-runtime 安装babel转换的语法：cnpm i -D @babel/preset-env 在webpack.config.js中添加相关loader模块，并排除node_modules 123456789101112// babel{ test: /\\.js$/, exclude: /node_modules/, use: { loader: \"babel-loader\", options: { presets: [\"@babel/preset-env\"], plugins: [\"@babel/plugin-transform-runtime\"] } }} webpack-dev-server实时打包这种打包方式会将输出的js文件打包到内存中，当我们需要引用这个js文件的时候，直接把它当成在根路径下即可成功 步骤 安装：npm i -g webpack-dev-server 在webpack.config.js 在package.json中配置，webpack-dev-server命令参数 1234567{ \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", // 添加这一行dev配置 \"dev\": \"webpack-dev-server --open --contentBase src\" }} 执行命令：npm run dev，此后我们修改文件后，就会自动打包 webpack-dev-server命令参数说明 --open：自动打开浏览器 --port：设置端口 --contentBase：设置根路径 --hot：热部署、局部刷新（异步） 也可以在webpack.config.js中指定webpack-dev-server命令参数 12345678910111213141516171819202122let path = require(\"path\"); // 导入路径处理库let webpack = require(\"webpack\");module.exports = { // 配置项目入口 entry: path.resolve(__dirname, \"src/main.js\"), // 配置输出选项 output: { path: path.resolve(__dirname, \"dist\"), filename: \"bundle.js\" }, // 配置webpack-dev-server的命令参数 devServer: { open: true, contentBase: \"src\", hot: true }, plugins: [ // 热更新模块对象 new webpack.HotModuleReplacementPlugin() ]} live-server这是一款带有热加载功能的小型开发服务器。用它来展示你的HTML / JavaScript / CSS，但不能用于部署最终的网站。（用于多页面热部署） 安装：npm install -g live-server 运行：live-server --port=80 html-webpack-plugin这个插件可以帮我们在内存中生成html页面，并自动帮我们引用打包后的bundle.js文件 安装插件：npm i html-webpack-plugin -D 在webpack.config.js中配置插件 123456789101112131415let path = require(\"path\"); // 导入路径处理库let htmlWebpackPlugin = require(\"html-webpack-plugin\");module.exports = { // ..... plugins: [ new htmlWebpackPlugin({ // 模板页面、生成页面的名字 template: path.join(__dirname, \"src/index.html\"), filename: \"index.html\" }) ]} 使用vue 安装依赖 cnpm i vue -S cnpm i vue-loader vue-template-compiler -D 修改配置文件webpack.config.js 123456789101112131415const vueLoaderPlugin = require(\"vue-loader/lib/plugin\");module.exports = { module: { rules: [ // vue-loader {test: /\\.vue/, use: \"vue-loader\"} ] }, plugins: [ // vueloader插件 new vueLoaderPlugin() ],} 创建一个vue单文件组件， app.vue 123456789101112131415161718192021&lt;!-- 组件模板 --&gt;&lt;template&gt; &lt;h2&gt;{{msg}}&lt;/h2&gt;&lt;/template&gt;&lt;!-- 组件逻辑代码--&gt;&lt;script&gt;export default { data() { return {msg: &quot;hello world&quot;} }, methods: {} // .....}&lt;/script&gt;&lt;!-- 如果不使用scoped属性，则定义的是全局样式 --&gt;&lt;!-- lang属性可以指定语言，如scss,less --&gt;&lt;style scoped&gt;&lt;/style&gt; 在入口js文件中引用 123456789import Vue from \"vue\"import app from \"./component/app.vue\"let vm = new Vue({ el: \"#app\", // 用于渲染组件，这种渲染方式会把el指定的容器中的内容覆盖掉 // createElement是一个回调函数，该函数返回指定组件渲染出来的html结果 render: ce =&gt; ce(app)}); 使用vue-router 新增account，login，register单文件vue组件，分别对应三条路由 安装vue-router，并在入口js文件中引入，然后在将其挂载到Vue上Vue.use(VueRouter) 然后可以创建路由啦 123456789101112131415161718192021222324252627282930313233import \"./css/index.css\"import Vue from \"vue\"import VueRouter from \"vue-router\"import app from \"./component/app.vue\"import account from \"./component/account.vue\"import login from \"./component/login.vue\"import register from \"./component/register.vue\"Vue.use(VueRouter); // 将VueRouter挂载到Vue上const router = new VueRouter({ routes: [ {path: \"/\", redirect: \"/account\"}, { path: \"/account\", component: account, children: [ {path: \"login\", component: login}, {path: \"register\", component: register} ] } ]})let vm = new Vue({ el: \"#app\", // 用于渲染组件，这种渲染方式会把el指定的容器中的内容覆盖掉 // createElement是一个回调函数，该函数返回指定组件渲染出来的html结果 render: ce =&gt; ce(app), router}); import注意事项 如果是导入当前项目中我们自己的资源，则应使用./ 没有./则会到node_modules目录中去找 node-modules/模块名 –&gt; package.json –&gt; 然后引入main属性指定的文件 vue脚手架安装@vue/cli, @vue/cli-init 命令行工具：vue init webpack 项目名 图形工具：vue ui","link":"/2021/03/06/js/vue/"},{"title":"使用chrome原生工具进行网页截图","text":"特点速度快，分辨率高, 要求Chrome版本为59或更高 截全图按下F12打开调试界面, 然后按下ctrl+shift+p，输入命令Capture full size screenshot 截图网页一部分按下ctrl+shift+c嗅探元素，然后选择要截取的部分，再运行Capture node screenshot命令","link":"/2018/12/01/tools/chrome-screenshot/"},{"title":"使用git管理svn","text":"文档：https://git-scm.com/docs/git-svn 常用操作1234567891011121314151617181920# 下载一个 SVN 项目和它的整个代码历史，并初始化为 Git 代码库git svn clone [repository]# 从第10个版本开始检出git svn clone -r10:HEAD [repository]​# 查看当前版本库情况git svn info​# 取回远程仓库所有分支的变化git svn fetch​# 取回远程仓库当前分支的变化，并与本地分支变基合并git svn rebase ​# 上传当前分支的本地仓库到远程仓库git svn dcommit​# 拉取新分支，并提交到远程仓库svn copy [remote_branch] [new_remote_branch] -m [message]","link":"/2021/03/01/tools/git-svn/"},{"title":"Git的使用","text":"Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 git工作区域 工作区(Working Directory): 添加、编辑、修改文件等操作 暂存区： 暂存修改的文件，最后统一提交到git仓库 git仓库(Git Repository)：最终确认的文件保存到仓库，成为一个新的版本 git初始化及仓库创建1234567891011# 1.设置用户名git config --global user.name 'username'# 2.设置用户邮箱git config --global user.email '邮箱地址'# 3.创建工作目录，初始化仓库git init# 查看用户信息git config --list 向仓库中添加文件步骤12345678# 1.将文件从工作区提交到暂存区git add 文件名# 2.将文件从暂存区提交到git仓库git commit -m '描述信息'# 查看仓库状态git status 删除git仓库文件12345678# 1.删除工作区文件rm 文件名# 2.从git中删除文件git rm 文件名# 3.提交git commit -m '描述信息' git远程仓库作用：实现代码的备份、共享 1234567891011121314151617# 1.将远程仓库内容复制到本地git clone 远程仓库地址# 2.将本地仓库数据上传到git pull 远程仓库地址# 查看当前配置可用的远程仓库信息git remote [-v]# 添加远程仓库git remote add origin &lt;url&gt;# 删除远端库git remote remove# 从远程仓库更新本地仓库git pull git分支123456789101112131415161718git checkout -b 分支名 # 从当前分支创建一个新分支git checkout -b [local_branch] [remote_branch] # 创建远程分支对应的本地分支git checkout 分子名 # 切换分支git branch # 查看本地所有分支git branch -a # 查看所有分支git push origin --delete # 删除分支远端分支git branch -d # 删除本地分支# 合并分支， 如：将login分支合并到master分支git checkout mastergit merge login# 将其它分支(非master)，提交到远程仓库git checkout logingit push -u origin login # 将login分支推送到云端，并记录分login分支 变基 git rebase1234567git cherry-pick [commit id] # 将其他分支上的commit遴选到当前分支git rebase [branch] # 将当前分支变基到[branch]分支上git rebase -i HEAD~n # 修改最近n次提交git rebase --edit-todogit rebase --continuegit rebase —abort 其他操作添加git忽略清单在根目录下添加.gitignore文件，该文件中指定内容将被忽略 查看提交版本次数1git log 回退到指定版本1git reset 忽略文件修改1234# 假定文件未更改git update-index --assume-unchanged [file]# 取消git update-index --no-assume-unchanged [file] 使用ssh进行更新远程仓库12345678# 1.将远程仓库内容复制到本地git clone 远程仓库地址# 2.更改远程仓库urlgit remote set-url origin &lt;sshurl&gt;# 3.将本地仓库数据上传到git push Commit message 和 Change log 编写https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html Github搜索技巧 in:name str in:readme str in:description str stars:&gt;1000 forks:&gt;1000 pushed:&gt;2020-1-1 language:java 参考 git-rebae: http://jartto.wang/2018/12/11/git-rebase/","link":"/2020/05/01/tools/git/"},{"title":"grep、sed、awk 命令","text":"学习使用 grep、sed、awk 命令 正则表达式匹配开头结尾 ^ 匹配开头 例子：^abc 匹配以abc开头的 $ 匹配结尾 例子：abc$ 匹配以abc结尾的 ^$ 匹配空 匹配单个字符 字符 功能 [] 匹配括号中的任意一个字符, 括号中加^[^]表示匹配非括号中字符任意一个 \\d 匹配一个数字, 0-9 \\D 匹配一个非数字 \\s 匹配空白, 即空格,tab… \\S 匹配非空白 \\w 匹配一个单词字符, a-z, A-Z, 0-9, _, 各国语言的字 \\W 匹配一个非单词字符 . 匹配任意一个字符(\\n除外)， 在DOTALL模式能匹配换行符 匹配多个字符 字符 功能 * 匹配前一个字符0或多次 + 匹配前一个字符1或多次 ? 匹配前一个字符0或1次 {m} 匹配前一个字符m次 {m, n} 匹配前一个字符m到n次 {m, } 匹配前一个字符m次以上 {, n} 最多匹配前一个字符n次 匹配分组 字符 功能 | 匹配左右任意一个表达式 () 将括号中的字符作为一个分组， 分组号从1开始 grep 命令命令格式： grep [OPTIONS] PATTERN [FILE...] 用于过滤 参数 12345678910-v: 选中没有匹配到的行-E: 等同于`egrep`， 使支持拓展正则(`+ | () {} ? `)-w: 精确匹配整个单词（过滤端口、进程的时候可以使用） --word-regexp-i: 忽略大小写-o: 仅输出匹配到的内容-c: 输出匹配到的行数-n: 显示行号-An: 输出匹配到的内容及其后面的 n 行 --after-context-Bn: 输出匹配到的内容及其前面的 n 行 --before-context-Cn: 输出匹配到的内容及其前后面的 n 行 --context 练习 123456789101112131415# 排除空行grep -v '^$' /etc/profile# 排除空行和'#'注释的行grep -vE '^$|^#' /etc/profilegrep -vE '^($|#)' /etc/profile# 输出文件中的单词 egrep -o '[a-Z]+' /etc/profile# 匹配 hello | halloecho -e 'hello world\\nhallo world' | grep -oE 'h(e|a)llo'# ps + grep 查看进程是否运行 会匹配到此时运行的命令ps -ef | grep dockerd# 不会配自身ps -ef | grep dockerd | grep -v grepps -ef | grep [d]ockerd # 此时运行的命令`grep [d]ockerd`， 二我们要找的是 dockerd sed 命令sed - stream editor for filtering and transforming text命令格式：sed [OPTION]... {script-only-if-no-other-script} [input-file]执行流程：按行读取内容到模式空间；匹配内容；执行增删改查操作 参数： -n: 取消模式空间默认输出-r: 使其支持拓展正则 增删改查12345678p: 打印 d: 删除 deletec: 替换一行的内容a: 指定行后面追加内容i: 指定行前面插入内容s: 替换 substitute 查 p 注意： 只想输出指定内容时，一定要使用 -n 参数 (sed -n ...)，取消模式空间默认输出 12345'np': 查第 n 行， 注意不是 /n/'m,np': 查 m 到 n 行'/regexp/p': 查 // 中表达式命中的行，类似grep'/reg1/,/reg2/p': 查表达式1命中的行，到表达式2命中的行。注意：如果表达式2没有命中内容，则会一直查到文件结尾，并输出。'n,/reg/p': 混用 删 d 12'nd'：删除第n行'$d'：删除最后一行 增 a,i 12'ni str': 在第n行前插入 str\\n'na str': 在第n行后增加 str\\n 替换 s 格式：sed 's/old/new/g' 将 old（可以是表达式），匹配到的内容，替换成 new /: 三个’/‘ 是分隔符，也可以用其它的符号表示， 如：’#’、‘@’ g: 全局替换，不加 ‘g’ 默认只替换每行第一个匹配到的内容 例子 123456789101112# 打印配置，排除空行、注释sed -r '/^$|^#/d' /etc/profile # 默认不修改文件，打印删除后的内容sed -nr '/^$|^#/!p' /etc/profile # '!' 取反， !p，表示不打印命中的内容# 分组 \\1, \\2 ... 引用内容echo hello world | sed -r 's/(.*) (.*)/\\2 \\1/' # 交换前后两个单词的位置# 取所有网卡 ipip addr | sed -nr '/^ +inet .*/p' | sed -r 's#^.* (.*)/.*#\\1#'# 取eth0网卡 ipip addr show eth0 | sed -n '3p' | sed -r 's#^.* (.*)/.*#\\1#'ip addr show eth0 | sed -nr '3s#^.* (.*)/.*#\\1#p' # 打印行、替换合并版 N/n 指令N: 先读入第一行到pattern space，然后执行N命令，将第二行追加进pattern space。此时模式空间数据： ‘第一行内容\\n第二行内容’n: 先读入第一行到pattern space，然后执行n命令，用第二行覆盖pattern space。此时模式空间只有第二行内容 12345678seq 1 10 | sed -n 'p;n' # 奇数seq 1 10 | sed -n 'n;p' # 偶数# 合并奇偶行seq 1 8 |sed -n 'N; s/\\n//p'12345678 awk 命令gawk - pattern scanning and processing language 常用于过滤、统计计算、对比比较 命令格式： awk [-W option] [-F value] [-v var=value] [–] ‘program text’ [file …] awk [-W option] [-F value] [-v var=value] [-f program-file] [–] [file …] awk 参数选项 ‘条件 {动作}’ 条件：比较符号、正则、范围表达式、特殊条件： BEGIN、END 置变量： NR: Number of Record 记录号 即行号 NF: Number of Field 每行的字段数，即列数 FS: Field Separator 字段分割符，即列分隔符 OFS: Output Field Separator 输出字段分割符 参数： -F: 指定列分隔符， 默认（空白符、连续的空白符） -v: 设置变量 -vFS=:：相当于 -F: 设置列分隔符分’:’ -vOFS=:：设置输出分隔符分’:’ 行与列行：awk叫 record , 默认通过回车分割 列：awk叫 field（字段、域），默认通过空格分隔 取行 123456789101112131415# 取第一行awk 'NR==1' /etc/passwd# 取三到五行awk 'NR==1,NR==3' /etc/passwdawk 'NR&gt;=3 &amp;&amp; NR&lt;=5' /etc/passwd# 取第三、第五行awk 'NR==3 || NR==5' /etc/passwd# 使用正则# 取包含 sys 的行awk '/sys/' /etc/passwd# 取 s 开头的行awk '/^s/' /etc/passwd# 从包含 root 的行， 取到包含 sys 的行awk '/root/,/sys/' /etc/passwd 取列 $n: 引用第n列 $NF: 引用最后一列 $0: 引用整行，即 $1 $2 … $NF $n~/reg/: 第n列满足表达式reg的 $n!~/reg/: 第n列满足表达式reg的 1234567891011121314# 取第一列和最后一列awk -F: '{print $1,$NF}' /etc/passwd | column -t# 取第一列和最后一列 输出使用 ':' 分割awk -F: '{print $1\":\"$NF}' /etc/passwdawk -F: -vOFS=: '{print $1,$NF}' /etc/passwd# 取用户标识号大于100的awk -F: '$3&gt;=100{print $1,$3}' /etc/passwd | column -t# 取可以登录的用户awk -F: '$NF!~/nologin$/ {print $1}' /etc/passwd# 取网卡IP地址ip addr show eth0 | awk -F'[ /]+' 'NR==3 {print $3}'ip addr | awk -F'[ /]+' '/inet / {print $3}' 特殊模式 BEGIN{}、END{} 模式 含义 应用场景 BEGIN{} 读取文件前执行 1. 进行简单计算，不涉及文件读取2.处理文件前添加表头3.定义awk变量（仅仅是定义变量，建议使用-v参数） END{} 读取文件后执行 1. 进行统计2.用来输出数组内容 123456789101112# 累加求和seq 100 | awk '{sum=sum+$1; print sum}'seq 100 | awk '{sum=sum+$1} END{print sum}' # 只打印最后结果awk 'BEGIN{for(i=1;i&lt;=100;++i) {sum+=i} print(sum)}'awk 'BEGIN{for(i=1;i&lt;=100;++i) sum+=i; print(sum)}'# 数组使用awk 'BEGIN{arr[0]=1234;arr[1]=\"hello world\"; for(i in arr) print i,arr[i]}'# 统计历史命令输入的次数history | awk '{arr[$2]++} END{for(i in arr) print i, arr[i]}' | sort -rnk2# 输出单词长度大于等于5的echo 'hello awk!' | awk -F'[ !]+' '{for(i=1;i&lt;=NF;++i) if(length($i)&gt;=5) print $i}' tips: awk 字符串 需要使用 双引号, 否则会被当做变量标志符","link":"/2021/11/04/tools/grep-sed-awk/"},{"title":"idea","text":"idea idea快捷键 快捷键 功能 Ctrl + Alt + Ins 新建… Alt+Enter 导入包，自动修正代码 Alt+Ins 自动生成代码，toString，get，set等方法 Ctrl+Alt+L 格式化代码 Ctrl+/ 单行注释 Ctrl+Shift+/ 选中代码注释，多行注释，再按取消注释 Ctrl+Y 删除光标所在行 Ctrl+D 复制光标所在行的内容，插入光标位置下面 Alt+Shift+上下箭头 移动当前代码行 Ctrl + Alt + V / .var 补全等号左边的变量定义 shift + f6 重构 ctrl+w选中变量, alt+j选中下面同名变量 批量修改变量名 fori / obj.for for / foreach Shift + alt + t 代码块。。。 ctrl + alt + m 将代码块抽取为一个新函数 Ctrl + R [+Shift] [全局]替换 {Match Case, Words, Regex} Ctrl + f [+Shift] [全局]查找 Ctrl + p 提示函数参数相关信息 Ctrl + q quick javadoc Ctrl + [ / ] move code block start/end Ctrl + N / Ctrl + shift + N / 2 shift 搜索类/文件/所有 Ctrl + Alt + B 跳转到方法体中 ctrl + f12 / Alt + 7 查看类的所有成员 ctrl + h / Alt + 8 查看类/接口的继承/实现关系 Alt + number 显示/隐藏组件 ctrl + shift + space 智能提示传递的参数 ctrl+` switch mode/theme/… 修改idea默认快捷键 Setting -&gt; keyMap –&gt; -&gt; Main menu -&gt; file/code/edit/…. 改ideaVim与idea快捷键冲突 Editor -&gt; Vim Emulation idea插件 ideaVIM lombok alibaba translation easy code：代码生成 GsonFormat：格式化json，并转化为实体属性 (Alt + S)","link":"/2020/05/01/tools/idea/"},{"title":"markdown 常用语法","text":"markdown 常用语法 1.换行两个空格加一个回车 2.标题1234# 一级标题## 二级标题### 三级标题... 效果： 一级标题二级标题三级标题3.区块引用例如:： 12345&gt; hello world &gt; &gt;&gt; hello world &gt; &gt; hello world 效果： hello world hello world hello world 4.列表无序列表使用 星号、加号 或是 减号作为列表标记有序列表则使用数字接着一个英文句点 例如:： 1234- hello world 1. hello world 2. hello world - hello world 效果： hello world hello world hello world hello world 5.行内代码、代码块行内代码123语法：使用一对反引号引起来例如：`int a = 10`; 效果： int a = 10 代码块使用三对反引号、&lt;pre&gt;`标签、tab缩进建立代码块时，建议指名代码语言 例如:： 12```pythonprint(\"hello world\") 1234&lt;font color='orange'&gt;效果&lt;/font&gt;：​```pythonprint(&quot;hello world&quot;) 链接自动链接(超链接)用尖括号包起来， 就会自动转成链接语法是：[链接名称](链接地址) 例如:： 12&lt;www.baidu.com&gt;[百度](www.baidu.com) 效果：https://www.baidu.com百度 也可以先定义链接，然后在其他位置重复使用 定义：[链接名称]:链接地址 使用：[链接名称][] 例如:： 123[百度]:www.baidu.com - [百度][]- [百度][] 效果:： 百度 百度 图片链接语法： 1![描述信息](图片链接地址 &quot;可选提示文本&quot;) ## 反斜杆转义 例如： 123456\\\\ 反斜线\\` 反引号\\* 星号\\# 井字号\\+ 加号\\- 减号 效果：\\ ` * # + -","link":"/2018/11/28/tools/markdown/"},{"title":"tmux 终端复用工具","text":"tmux 终端复用工具 安装：yum -y install tmux 新键一个会话: tmux new -s 会话名 操作ctrl + b 激活控制台，然后输入其它指令 %：竖分屏“：横向分屏 方向键：各屏键移动 d：脱离当前会话， 使用tmux attach进入会话 使用脚本操作tmux新建一个后台会话：tmux new-session -s 会话名 -d发送keys: tmux send-keys -t 会话名 ‘ls -l’ C-m C-m表示ctrl+m, 表示发送一个回车键","link":"/2018/12/01/tools/tmux/"},{"title":"学习使用vim","text":"*tips: * 交换ctrl键与caps键的位置 使用ctrl + [ 替代 esc 移动光标(命令模式下)上下左右 hjkl: 左下上右 可以在hjkl前加数字 5j: 下移5行 5h: 左移5个字符 基于单词移动 w：正向移动到下一单词的开头 b：反向移动到当前单词/上一单词的开头 e：正向移动到当前单词/下一单词的结尾 ge：方向移动到上衣单词的结尾 对行内字符进行查找并移动光标 f{char}: 正向移动到下一个char所在之处 F{char}: 反向… t{char}: 正向移动到下一个char所在之处的前一个字符上 T{char}: 方向移动… 用t找标点 ;: 重复上次字符查找命令 ,: 反转方向查找上次字符查找命令 移动多行 { }: 移动到前一个/后一个 段落的开头 ( ): 移动到前一个/后一个 句子的开头 [m ]m: 移动到前一个/后一个 函数的开始 ctrl + f: 下翻页 ctrl + b: 上翻页 ctrl + d: 下翻半页 ctrl + u: 上翻本页 设置标记，快速回跳 m{mark} `{mark} 文本对象的选择(可视模式)分隔符文本对象 a + ) / ] / } / &gt; ‘ / “ / ` a – around 选中分隔符及其内的文本 i + ) / ] / } / &gt; ‘ / “ / ` insert 选中分隔符内的文本， 不包括分隔符 a/i + b == a/i + ) a/i + t: 选中xml标签 范围文本对象 iw: 选中当前单词 aw: 选中当前单词及其后的空格 i/a + w: 选字符串 i/a + s: 选句子 i/a + p: 选段落 操作符待决模式{motion}{motion}：分隔符文本对象和范围文本对象 d{motion} : 删除模式 c{motion} : 修改模式 y{motion} : 复制模式 v{motion} : 可视模式 寄存器 寄存器是vim保存临时数据的地方。 查看寄存器 :reg :reg registerName 取寄存器的值 “registerName + registerName 寄存器分类 无名寄存器(“) 默认寄存器，x,s,d,c,y的数据都会存入到改寄存器 数字寄存器(0-9) 0：复制专用寄存器(y操作) 1-9：逐级临时缓存寄存器 所有不带范围（‘(’，‘)’，‘{’，‘}’）、操作涉及1行以上的删除修改操作（x、s、d、c）的数据都会复制到逐级临时缓存寄存器 新的数据加入时，逐级先后推移。 黑洞寄存器(_) 数据到该寄存器会消失掉。所有对于一些不需要的记录的数据，可以指定到该寄存器。 系统剪切板(+ *) +: copy了的数据 *: 选中的但为copy的数据 表达式寄存器(=) 用于计算表达式 其他寄存器 %：记录当前文件名，包含文件路径 /：记录上次查找的内容 .：记录上次插入的内容 宏录制 录制(normal mode) q + registerName: 开始录制 q: 结束录制 使用(normal mode) @ + 存入的寄存的名字 @@：重复使用上一次的宏 批量操作 块模式下选中要操作的行 :normal @registerName 查找替换查找 /{pattern}: 查找 *: 正向查找光标所在单词 #: 反向查找光标所在单词 替换 全局替换: :%s/{pattern}/{string}/g %: 代表全文 s: 代表substitute g: global 可视区域替换 可视模式选区域 :s/{pattern}/{string}/g","link":"/2018/12/01/tools/vim/"},{"title":"xml","text":"xml是一种可拓展标记语言,是w3c组织发布的。可拓展就是标签可以自己定义。xml两个版本1.1版本不能向下兼容，1.0使用较多。xml由软件解析，用户编写（按照说明文档），说明文档有软件开发者提供。 xml与html区别 xml标签都是自定义的，html标签是预定义。 xml的语法严格，html语法松散 xml是存储数据的，html是展示数据 xml应用 用于不用系统之间的数据传输 用来表示生活中有关系的数据 用作配置文件 xml语法 文件后缀名为.xml, 首行文档声明（xml版本号，xml字符编码…）。 属性值必须使用引号引起来 文档声明12&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?&gt;&lt;!-- standalone:是否依赖其他文件, no表示依赖 --&gt; PI指令 引入css文件，该文件的样式只对英文标签起作用，对xml中文标签不起作用 1&lt;?xml-stylesheet type=\"text/css\" href=\"a.css\" ?&gt; &lt;!--引入css样式&gt; 标签: 自定义 xml区分大小写 xml标签不能以数字和下划线开头，不能以xml开头，标签中不能有空格，冒号 标签可以嵌套若干子标签，但不允许交叉嵌套 xml会把空格和换行都当成内容来解析 12包含标签主题：&lt;tmp&gt;&lt;/tmp&gt;不含标签主题：&lt;/tmp&gt; 属性1&lt;tmp id=\"1\" class=\"tmp\"&gt;&lt;/tmp&gt; 文本 普通标签中的文本不能使用特殊字符，需要转义。CDATA区中的数据会被原样展示。 123&lt;![CDATA[ 数据]]&gt; 特殊字符 特殊字符 &lt; &gt; &amp; ‘ “ 替代符号 &amp;lt; &amp;gt; &amp;amp; &amp;apos; &amp;quot; dtd约束 有几个xml元素就定义几个&lt;ELEMENT&gt;标签 复杂元素(有子元素的元素), 约束元素中包含的子元素 &lt;!ELEMENT 元素名称 (子元素,子元素)&gt; 简单元素, 约束元素为字符类型 &lt;!ELEMENT 元素名称 (#PCDATA)&gt; 约束元素的属性 &lt;!ELEMENT 元素名称 属性名 属性类型 练习 123456&lt;!ELEMENT students (student*) &gt; &lt;!-- students标签下可以有任意个student标签 --&gt;&lt;!ELEMENT student (name,age,sex)&gt; &lt;!-- student标签下只能由name,age,sex标签 --&gt;&lt;!ELEMENT name (#PCDATA)&gt; &lt;!-- name标签为简单元素: 不能由子元素 --&gt;&lt;!ELEMENT age (#PCDATA)&gt; &lt;!ELEMENT sex (#PCDATA)&gt;&lt;!ATTLIST student number ID #REQUIRED&gt; &lt;!-- student有number属性, 属性值唯一，且必须有--&gt; dtd三种引入方式 12345678910&lt;!-- 1. xml文件中直接编写(内部dtd) --&gt;&lt;!DOCTYPE 根元素名称 [ dad约束]&gt;&lt;!-- 2. 引用外部dtd文件 --&gt;&lt;DOCTYPE 根元素(标签)名称 SYSTEM \"dtd文件路径\"&gt; &lt;!-- 3. 引用网络上的dtd文件 --&gt;&lt;!DOCTYPE 根元素名称 PUBLIC \"dtd文件名称\" \"dtd文件URL\"&gt; Schema约束 文件名*.xsd, 是一种复杂约束 引入 填写xml文档的根元素 引入xsi前缀. xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 引入xsd文件命名空间 xsi:schemaLocation=&quot;http://www.ttt.cn/xml student.xsd&quot; 为每一个xsd约束声明一个前缀,作为标识 xmlns=&quot;http://www.ttt.cn/xml&quot; 例如 123&lt;students xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns=\"http://www.ttt.cn/xml\"xsi:schemaLocation=\"http://www.ttt.cn/xml student.xsd\"&gt; 操作xml 解析(读取)：将文档中的数据读取到内存中 写入：将内存中的数据保存到xml文档中。持久化的存储 解析xml的方式 服务器采用dom的思想，移动端采用SAX思想 DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树 优点：操作方便，可以对文档进行CRUD(增删改查)的所有操作 缺点：占内存 SAX：逐行读取，基于事件驱动的。 优点：不占内存。 缺点：只能读取，不能增删改 xml常见的解析器 JAXP：sun公司提供的解析器，支持dom和sax两种思想, 使用较少。 DOM4J：一款非常优秀的解析器, 服务器端使用多 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 PULL：Android操作系统内置的解析器，sax方式的。 Jsoup解析器对象使用 Jsoup：工具类，可以解析html或xml文档，返回Document parse方法：解析html或xml文档，返回Document parse(File in, String charsetName)：解析xml或html文件的。 parse(String html)：解析xml或html字符串 parse(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 Document：文档对象。代表内存中的dom树，Document对象继承了Element对象 获取Element对象 getElementById(String id)：根据id属性值获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合 Element：元素对象 Elements：元素Element对象的集合。可以当做ArrayList&lt;Element&gt;来使用 获取子元素对象 getElementById(String id)：根据id属性值获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据属性名和值， … 获取属性值 String attr(String key)：根据属性名称获取属性值， 不区分属性名的大小写 获取文本内容 String text(): 获取文本内容（不包括子标签的标签体） String html(): 获取标签体的所有内容(包括子标签的标签体) Node：节点对象 是Element, Document的父类 步骤： 导入jar包 获取Document对象 获取对应的标签Element对象 获取数据 练习 1234567891011121314// 获取xml文件的Document对象String path = jsoup.class.getClassLoader().getResource(\"xml/dtd/student.xml\").getPath();Document document = Jsoup.parse(new File(path), \"utf-8\");// 获取带有number属性的元素Elements number = document.getElementsByAttribute(\"number\");System.out.println(number);System.out.println(\"-----------------------\");System.out.println(number.get(0).text());System.out.println(\"-----------------------\");// 获取带有number属性的元素下的age标签Elements age = number.get(0).getElementsByTag(\"age\");System.out.println(age.get(0).text()); 快速选择标签 selector:选择器 使用的Element对象中的方法：Elements select(String cssQuery) 语法：参考Selector类中定义的语法 XPath：XPath即为XML路径语言 导入JsoupXpath.jar包。 获取JXDocument对象 JXDocument jxDocument = new JXDocument(document); 选择标签 使用JXDocument对象中的sel, selN, selOne, selNOne方法 例子： 选择student小的age标签 123456789101112// 获取xml文件的Document对象String path = jsoup.class.getClassLoader().getResource(\"xml/dtd/student.xml\").getPath();Document document = Jsoup.parse(new File(path), \"utf-8\");// 使用 Selector 选择Elements elements = document.select(\"student&gt;age\");System.out.println(elements.text());// 使用 Xpath 选择JXDocument jxDocument = new JXDocument(document);List&lt;JXNode&gt; jxNodes = jxDocument.selN(\"//student/age\");System.out.println(jxNodes);","link":"/2020/03/18/tools/xml/"},{"title":"使用hexo和github搭建个人博客","text":"使用hexo和github搭建个人博客 准备工作 安装git bash 安装nodejs：官网 安装hexo：npm i hexo-cli -g hexo常用命令官网文档：https://hexo.io/docs/commands 建立网站1hexo init 新建文章使用该命令后，会在source/_posts/目录下建立title.md文件 1hexo new &lt;title&gt; 启动hexo服务1hexo server 生成静态文件1hexo generate 部署网站1hexo deploy 清除文件使用改名会清理缓存文件 (db.json) 和已生成的静态文件 (public) 1hexo clean 搭建个人博客本地搭建blog 在本地初始化博客项目 1234cd /d/workspace # 进入一个工作目录hexo init blog # 初始化blogcd blognpm install # 安装依赖 设置博客标题和博主：打开配置文件_config.yml ，找到下面配置 1234567# Sitetitle: tcbaby's blogsubtitle: ''description: ''keywords:author: tcbabylanguage: en 使用hexo server命令，启动博客项目。访问http://localhost:4000/即可看到我们的博客。 GitHub Page 在GitHub上创建一个用户名.github.io的仓库 在_config.yml文件中指定仓库地址 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:tcbaby/tcbaby.github.io.git branch: master 生成静态文件并推送到GitHub仓库 1hexo g &amp;&amp; hexo d 访问https://用户名.github.io即可。 其它配置更换主题官网主题：https://hexo.io/themes/icarus主题：文档选择好自己喜欢的主题后，下载到themes目录下，修改_config.yml配置文件中theme 1theme: icarus 访问统计插件访问统计：http://ibruce.info/2015/04/04/busuanzi/ 1234567891011&lt;!-- 网站访问量 --&gt;&lt;script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt;&lt;p style=\"font-size:12px; color: burlywood\"&gt; 本站总访问量:&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt; 本站访客数:&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;!-- 文章阅读量 --&gt;&lt;script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt;&lt;span id=\"busuanzi_container_page_pv\"&gt; 本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次&lt;/span&gt;","link":"/2020/04/30/tools/%E4%BD%BF%E7%94%A8hexo&github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Json","slug":"Json","link":"/tags/Json/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Thymeleaf","slug":"Thymeleaf","link":"/tags/Thymeleaf/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"es","slug":"es","link":"/tags/es/"},{"name":"mongo","slug":"mongo","link":"/tags/mongo/"},{"name":"neo4j","slug":"neo4j","link":"/tags/neo4j/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"AJAX","slug":"AJAX","link":"/tags/AJAX/"},{"name":"CORS","slug":"CORS","link":"/tags/CORS/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"git-svn","slug":"git-svn","link":"/tags/git-svn/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"regex","slug":"regex","link":"/tags/regex/"},{"name":"grep","slug":"grep","link":"/tags/grep/"},{"name":"sed","slug":"sed","link":"/tags/sed/"},{"name":"awk","slug":"awk","link":"/tags/awk/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"tmux","slug":"tmux","link":"/tags/tmux/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"xml","slug":"xml","link":"/tags/xml/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"database","slug":"database","link":"/categories/database/"},{"name":"js","slug":"js","link":"/categories/js/"},{"name":"tools","slug":"tools","link":"/categories/tools/"}]}